[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CƠ SỞ LẬP TRÌNH",
    "section": "",
    "text": "Giới thiệu\nĐây là sách tóm tắt về lập trình được viết dựa trên ngôn ngữ lập trình C. Sách được cấu trúc theo các chương. Mỗi chương gồm 2 phần: Phần lý thuyết: được tóm tắt ngắn gọn với đầy đủ ví dụ minh hoạ kèm theo. Phần bài tập: với nhiều bài tập được chia làm hai mức độ cơ bản và luyện tập nâng cao, bài tập có đánh dấu * là bài tập khó dành cho sinh viên luyện tập thêm.",
    "crumbs": [
      "Giới thiệu"
    ]
  },
  {
    "objectID": "chapter-1.html",
    "href": "chapter-1.html",
    "title": "1  CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH",
    "section": "",
    "text": "1.1 KHÁI NIỆM LẬP TRÌNH",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH</span>"
    ]
  },
  {
    "objectID": "chapter-1.html#khái-niệm-lập-trình",
    "href": "chapter-1.html#khái-niệm-lập-trình",
    "title": "1  CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH",
    "section": "",
    "text": "CPU của máy tính được thiết kế để có thể thực hiện được các chương trình mã máy ) đã được hệ điều hành (HĐH) nạp vào RAM của máy tính.\nChương trình mã máy thường phải tương thích với từng họ máy cụ thể, bao gồm tập hợp các chỉ thị được viết bằng các lệnh CPU của họ máy đó, được lưu trên đĩa dưới dạng một tập tin mã thực thi của HĐH cụ thể\n\n\n\nQuy trình thực hiện\n\nBước 1: Người sử dụng ra lệnh thực hiện chạy chương trình.\nBước 2: HĐH nhận được lệnh sẽ thực hiện:\n\nTìm và nạp tập tin mã thực thi của chương trình (nằm trên đĩa) vào RAM của máy tính.\nBộ đếm lệnh của CPU (CPU program counter) được trỏ đến lệnh đầu tiên của chương trình hay còn gọi là ngõ vào chương trình\n\nBước 3: CPU thực hiện từng chỉ thị một trong RAM cho đến khi gặp lệnh kết thúc:\n\nChép lệnh mã máy hiện hành vào thanh ghi lệnh.\nTăng bộ đếm lệnh (để trỏ đến lệnh kế tiếp).\nThi hành lệnh mã máy.\n\nBước 4: Kết thúc thực hiện chương trình, HĐH chờ nhận lệnh mới.\n\n\n\nĐặc điểm\n\nMỗi chỉ thị của chương trình là một lệnh mã máy (một dãy các byte chỉ phù hợp với qui ước tập lệnh của một loại CPU nào đó)\nĐược cấu trúc hóa theo qui ước của HĐH.\nĐược chạy trên một họ CPU và HĐH cụ thể.\nNội dung rất khó hiểu đối với người dùng máy tính, chỉ có CPU thích hợp với hiểu rõ và thi hành được.\n\n\n\nNhận xét\n\nKhó có thể sản xuất ra phần mềm bằng cách viết trực tiếp các chương trình mã máy.\nNếu có làm được theo cách này thì\n\nGiá cả sẽ rất đắt do quá khó, tốn quá nhiều thời gian và công sức.\nKhả năng dùng lại rất giới hạn do không thể bán chongười dùng trên họ máy tính khác hay người dùng sử dụng hệ điều hành khác.\n\n\n\n\nNgôn ngữ lập trình - NNLT là ngôn ngữ được lập trình viên sử dụng để viết chương trình cho máy tính.\nKhi một chương trình được viết bằng một NNLT nào đó thì các chỉ thị, câu lệnh trong chương trình phải tuân theo các qui tắc, các luật do NNLT đó qui định.\nChương trình viết bằng ngôn ngữ lập trình được gọi là chương trình nguồn hay mã nguồn. Chương trình nguồn được dịch sang chương trình mã máy bằng cách chương trình dịch:\n\nTrình hợp dịch để dịch các chương trình hợp ngữ.\nTrình thông dịch và trình biên dịch để dịch các chương trình cấp cao.\n\n\n\n\nMột số ngôn ngữ lập trình thông dụng\n\nNgôn ngữ cấp thấp: Hợp ngữ (assembly language)\nNgôn ngữ cấp cao: C/C++, Java, C#, Pascal, Python, PHP, Ruby, Perl, Lisp\n\n\n\n\nChương trình là một dãy các chỉ thị điều khiển sự hoạt động của máy tính nhằm giải quyết một công việc nào đó.\nNgười viết chương trình hay còn gọi là lập trình viên hay thảo chương viên là những người tạo lập ra những chương trình máy tính.\n\n\n\nMột số chương trình\n\nNgôn ngữ assembly\n\n.model tiny\n.code\norg 100h\n    main  proc\n        mov    ah,9\n        mov    dx,offset hello_message\n        int    21h\n        retn\n        hello_message db 'Hello, world!$\\$$'\n    main endp\nend main\n\nNgôn ngữ C/C++\n\n#include &lt;stdio.h&gt;\nvoid main(void)\n{\n    pritnf(\"Hello world!\");\n}\n\nNgôn ngữ Java\n\npublic class Hello {\n    public static void main(String argv[])\n    {\n        System.out.print(\"Hello everybody!\");\n    }\n}\n\n\n\nĐặc điểm ngôn ngữ lập trình cấp thấp\n\nLà NNLT phụ thuộc vào từng họ máy cụ thể, vì vậy không có tính tương thích.\nDễ viết, đọc, sửa hơn chương trình mã máy.\nƯu điểm là tận dụng và khai thác được tính năng của mỗi họ máy cụ thể, nhờ vậy chương trình có thể chạy nhanh hơn.\n\n\n\nĐặc điểm ngôn ngữ lập trình cấp cao\n\nĐược đề xuất để khắc phục các hạn chế của NNLT cấp thấp.\nDễ dùng và dễ diễn đạt được các ý tưởng trừu tượng.\nCó tính tương thích cao (khi thay đổi dạng máy tính thì chỉ cần sửa chương trình rất ít hoặc thậm chí không cần sửa mà vẫn đảm bảo chạy đúng).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH</span>"
    ]
  },
  {
    "objectID": "chapter-1.html#công-nghệ-lập-trình-truyền-thống",
    "href": "chapter-1.html#công-nghệ-lập-trình-truyền-thống",
    "title": "1  CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH",
    "section": "1.2 CÔNG NGHỆ LẬP TRÌNH TRUYỀN THỐNG",
    "text": "1.2 CÔNG NGHỆ LẬP TRÌNH TRUYỀN THỐNG\nĐối với các NNLT cấp cao truyền thống (trước thế hệ của C++, Java và C#), quá trình viết, dịch và chạy chương trình gồm các công đoạn như sau:\n\nB1. Soạn chương trình nguồn và lưu lên đĩa.\nB2. Dịch chương trình nguồn nhờ trình biên dịch.\nB3. Nối kết các tập tin mã trung gian tạo ra ở B2.\nB4. Chạy chương trình ngôn ngữ máy tạo ra ở B3.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH</span>"
    ]
  },
  {
    "objectID": "chapter-1.html#công-nghệ-lập-trình-hiện-đại",
    "href": "chapter-1.html#công-nghệ-lập-trình-hiện-đại",
    "title": "1  CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH",
    "section": "1.3 CÔNG NGHỆ LẬP TRÌNH HIỆN ĐẠI",
    "text": "1.3 CÔNG NGHỆ LẬP TRÌNH HIỆN ĐẠI\n\nHạn chế của các chương trình cấp cao truyền thống là trình biên dịch của chúng phát sinh trực tiếp mã thực thi phụ thuộc vào mã máy tính của một họ máy tính và hệ điều hành cụ thể nên không thể mang đi sử dụng ở các hệ điều hành khác.\nNNLT hiện đại như Java hay C# trình biên dịch không dịch trực tiếp mã nguồn thành mã thực thi mà được thiết kế để có thể dịch thành mã thực thi trừu tượng độc lập máy và hệ điều hành.\nDo máy tính thật không thể hiểu được mã trừu tượng nên những chương trình dạng mã thực thi trừu tượng chỉ chạy được khi có sẵn máy ảo hỗ trợ cho việc thi hành loại mã thực thi đó.\nTrong các năm gần đây, các ứng dụng chạy trên web phát triển rất mạnh.\n\nChạy trên internet thông qua một trình duyệt web.\nĐược viết bằng các ngôn ngữ như Python, PHP, ASP.NET, JSP, Java Script, VB Script… có tính tương thích cao, hoạt động trên bất kỳ máy tính nào có internet\n\n\n\nCông cụ và môi trường lập trình\nToàn bộ qui trình biên dịch được thực một cách dễ dàng và thuận tiện nhờ vào công cụ gọi là môi trường phát triển phần mềm - IDE\n\nSoạn thảo chương trình.\nQuản lý hệ thống tập tin mã nguồn.\nQuản lý hệ thống các phiên bản của mã nguồn.\nKiểm tra lỗi cú pháp (syntax error), biên dịch (compile), liên kết chương trình (link).\nChạy từng dòng lệnh (debug) để tìm lỗi.\n\n\nMột số IDE thông dụng\n\nEclipse: hỗ trợ nhiều ngôn ngữ lập trình.\nVisual Studio: hỗ trợ nghiều ngôn ngữ lập trình",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH</span>"
    ]
  },
  {
    "objectID": "chapter-1.html#thuật-toán",
    "href": "chapter-1.html#thuật-toán",
    "title": "1  CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH",
    "section": "1.4 THUẬT TOÁN",
    "text": "1.4 THUẬT TOÁN\n\nCác bước thiết kế chương trình\n\nXác định bài toán\nPhân tích bài toán\nThiết kế thuật toán\nCài đặt chương trình\nThử nghiệm chương trình\n\n\nThuật toán là tập hợp hữu hạn các chỉ thị được định nghĩa rõ ràng nhằm giải quyết một vấn đề cụ thể nào đó.\n\nMột thuật toán phải có các tính chất sau\n\nTính chính xác: quá trình tính toán hay các thao tác máy tính thực hiện là chính xác.\nTính rõ ràng: các câu lệnh minh bạch được sắp xếp theo thứ tự nhất định.\nTính khách quan: được viết bởi nhiều người trên máy tính nhưng kết quả phải như nhau.\nTính phổ dụng: có thể áp dụng cho một lớp các bài toán có đầu vào tương tự nhau.\nTính kết thúc: hữu hạn các bước tính toán\n\n\n\nTrình bày thuật toán như thế nào?\n\nTrình bày bằng ngôn ngữ tự nhiên\nTrình bày bằng mã giả\nTrình bày bằng lưu đồ\n\n\nHãy trình bày cách làm món sữa dâu bằng ngôn ngữ tự nhiên\nCách 1\n\nLấy một ít sữa.\nĐổ nước ép dâu vào.\nTrộn hỗn hợp này và làm lạnh.\n\nCách 2\n\nRót một ly sữa vào máy xay\nĐổ thêm vào một ít nước dâu ép\nĐóng nắm máy xay\nMở điện và bắt đầu trộn\nDừng máy trộn lại\nNếu đã trộn đều thì tắt máy, ngược lại thì trộn tiếp\nKhi đã trộn xong, rót hỗn hợp vào tô và đặt vào tủ lạnh\nĐể lạnh một lúc rồi lấy ra dùng\n\n\n\nHãy trình bày cách sắp xếp một dãy số L theo thứ tự tăng dần bằng ngôn ngữ mã giả\nMERGESORT(L)\nif SIZE(L)&gt; 1\n  SPLIT(L, L_{1}, L_{2}) (tách dãy L thành L_{1} và L_{2})\n  MERGESORT(L_{1}) (sắp xếp dãy L_{1})\n  MERGESORT(L_{2}) (sắp xếp dãy L_{2})\n  MERGE(L_{1}, L_{2}, L) (trộn dãy L_{1} và L_{2} thành L)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>CÁC KHÁI NIỆM CƠ BẢN VỀ LẬP TRÌNH</span>"
    ]
  },
  {
    "objectID": "chapter-2.html",
    "href": "chapter-2.html",
    "title": "2  LƯU ĐỒ THUẬT TOÁN",
    "section": "",
    "text": "2.1 LÝ THUYẾT\nChương này sẽ trình bày các ký hiệu biểu diễn lưu đồ thuật toán, cách biểu diễn các cấu trúc điều khiển rẽ nhánh, cấu trúc lặp và các kỹ thuật liên quan đến lưu đồ thuật toán.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>LƯU ĐỒ THUẬT TOÁN</span>"
    ]
  },
  {
    "objectID": "chapter-2.html#lý-thuyết",
    "href": "chapter-2.html#lý-thuyết",
    "title": "2  LƯU ĐỒ THUẬT TOÁN",
    "section": "",
    "text": "Khái niệm\nLưu đồ thuật toán là công cụ đồ thị dùng để biểu diễn thuật toán, việc mô tả nhập dữ liệu và xuất dữ liệu và xử lý dữ liệu thông qua các ký hiệu hình học.\n\n\nPhần mềm công cụ\nCác công cụ để vẽ lưu đồ như\n\nDrawio, Visio\nFlowchart có thể thực thi\n\n\n\nCác ký hiệu\n\n\n\nLệnh\nKý hiệu\nLệnh\nKý hiệu\n\n\n\n\nAssignment\n\nFor\n\n\n\nCall\n\nIf\n\n\n\nComment\n\nInput\n\n\n\nDeclare\n\nOutput\n\n\n\nDo\n\nWhile\n\n\n\n\n\n\nPhương pháp vẽ và thực thi\n\nVẽ từ trên xuống\nChạy bắt đầu từ Begin và kết thúc tại End\nĐi theo hướng mũi tên\n\n\n\nCác cấu trúc điều khiển cơ bản\n\nCấu trúc tuần tự\nTuần tự thực thi tiến trình. Mỗi lệnh được thực thi theo một chuỗi từ trên xuống, xong lệnh này rồi chuyển xuống lệnh kế tiếp.\n\nNhập vào một số nguyên a và xuất ra màn hình với giá trị tăng lên 1\n\n\n\nCấu trúc rẽ nhánh\nĐiểm quyết định cho phép chọn một trong hai trường hợp đúng hay sai\n\nNhập vào số nguyên n. Kiểm tra nếu n&gt;0 tăng n lên 1 đơn vị\n\n\n\nCấu trúc lặp\nThực hiện liên tục 1 lệnh hay tập lệnh với số lần lặp dựa vào điều kiện. Lặp sẽ kết thúc khi điều kiện được thỏa.\n\nNhập vào số nguyên n. Xuất ra màn hình từ 1 đến n.\n\n\n\nCác ví dụ thực hành\n\nGiải và biện luận phương trình: ax+b=0.\nTính tổng: S(n)=1+2+3+\\ldots+n với n&gt;0\nTính tổng: S(n)=\\frac{1}{2}+\\frac{2}{3}+\\frac{3}{4}+\\ldots+\\frac{2n+1}{2n+2} với n&gt;0\nTính tổng: S(n)=1-2+3-\\ldots+(-1)^{n+1}n với n&gt;0",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>LƯU ĐỒ THUẬT TOÁN</span>"
    ]
  },
  {
    "objectID": "chapter-2.html#bài-tập",
    "href": "chapter-2.html#bài-tập",
    "title": "2  LƯU ĐỒ THUẬT TOÁN",
    "section": "2.2 BÀI TẬP",
    "text": "2.2 BÀI TẬP\n\nBài tập cơ bản\n\nNhập vào hai số x,y. Xuất ra màn hình tổng, hiệu, tích, thương của hai số trên.\nNhập vào số nguyên n, kiểm tra xem n chẵn hay lẻ và xuất ra màn hình.\nNhập vào ba cạnh a,b,c của tam giác. Xuất ra màn hình tam giác đó thuộc loại tam giác gì? (thường, cân, vuông, đều hay vuông cân).\nNhập vào số nguyên n. Xuất n ra màn hình (nếu n chẵn thì gấp đôi giá trị).\nNhập vào số nguyên n. Nếu n&gt;5 thì tăng n lên 2 đơn vị và trả về giá trị n, ngược lại trả về giá trị 0.\nTính n!, với n\\geq0\nTính P(n)=1.3.5...(2n+1), với n\\geq0\nTính S(n)=1+3+5+...+(2n+1), với n\\geq0\nTính S(n)=1-2+3-4+...+(-1)^{n+1}n, với n&gt;0\nTính S(n)=1+1.2+1.2.3+...+1.2.3...n, với n&gt;0\nTính S(n)=1^{2}+2^{2}+3^{2}+...+n^{2}, với n&gt;0\nTính S(n)=1+\\frac{1}{2}+\\frac{1}{3}+...+\\frac{1}{n} với n&gt;0\n(*) Tính S(n)=1+\\frac{1}{1+2}+\\frac{1}{1+2+3}+...+\\frac{1}{1+2+3+...+n} với n&gt;0\nTính P(x,y)=x^{y}\nTính S(n)=1+(1+2)+(1+2+3)+...+(1+2+3+...+n) với n&gt;0\nCho số nguyên n. Tính trị tuyệt đối của n.\nCho số nguyên dương n gồm k chữ số. Tìm chữ số có giá trị lớn nhất.\nĐếm số lượng ước số chẵn của số nguyên dương n.\nIn ra chữ số đầu tiên của số nguyên dương n gồm k chữ số.\nCho 2 số nguyên dương a,b. Tìm USCLN của a và b.\nCho 2 số nguyên dương a,b. Tìm BSCNN của a và b.\nCho số nguyên dương x. Kiểm tra xem x có phải là số nguyên tố không?\nCho số nguyên dương x. Kiểm tra x có phải là số chính phương không?\nCho số nguyên dương x. Kiểm tra xem x có phải là số hoàn thiện không?\n\n\n\nBài tập luyện tập và nâng cao\n\nTính S(n)=1+2^{2}+3^{3}+...+n^{n}, với n&gt;0\nTính S(n)=\\frac{1}{2}+\\frac{2}{3}+...+\\frac{n}{n+1} với n&gt;0\nTính S(n)=1+\\frac{1}{2!}+\\frac{1}{3!}+\\ldots.+\\frac{1}{n!} với n&gt;0\nTính S(n)=1+\\frac{1+2}{2!}+\\frac{1+2+3}{3!}+\\ldots.+\\frac{1+2+3+...+n}{n!} với n&gt;0\nGiải và biện luận phương trình bậc hai ax^{2}+bx+c=0\nGiải và biện luận phương trình trùng phương bậc bốn ax^{4}+bx^{2}+c=0\n(*) Tính S(n)=\\sqrt{n+\\sqrt{n-1+\\sqrt{n-2+...+\\sqrt{1}}}} với n&gt;0\n(**) Tính S(n)=\\sqrt{1+\\sqrt{2+\\sqrt{3+...+\\sqrt{n}}}} với n&gt;0",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>LƯU ĐỒ THUẬT TOÁN</span>"
    ]
  },
  {
    "objectID": "chapter-2.html#tóm-tắt",
    "href": "chapter-2.html#tóm-tắt",
    "title": "2  LƯU ĐỒ THUẬT TOÁN",
    "section": "2.3 TÓM TẮT",
    "text": "2.3 TÓM TẮT\nLưu đồ thuật toán rất là một công cụ hữu ích trong việc mô tả cách giải quyết của một bài toán. Việc mô tả này rất trực quan thông qua các ký hiệu hình học, đây là giai đoạn đầu tiên trước khi bắt tay vào lập trình trên một ngôn ngữ lập trình cụ thể. Khi xây dựng lưu đồ thuật toán, chúng ta cần chú ý một vài điểm sau: Một lưu đồ phải có điểm bắt đầu và điểm kết thúc. Phải có dữ liệu vào, dữ liệu ra sau khi xử lý tính toán. Tại mỗi vị trí quyết định lựa chọn rẽ nhánh phải ghi rõ điều kiện đúng hoặc sai thì đi theo nhánh nào.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>LƯU ĐỒ THUẬT TOÁN</span>"
    ]
  },
  {
    "objectID": "chapter-3.html",
    "href": "chapter-3.html",
    "title": "3  KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN",
    "section": "",
    "text": "3.1 LÝ THUYẾT\nChương này trình bày các kiểu dữ liệu cơ bản và các phép toán tương ứng trong ngôn ngữ C, các cấu trúc rẽ nhánh, lặp. Mô tả cách hoạt động và hướng dẫn chạy từng bước chương trình.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN</span>"
    ]
  },
  {
    "objectID": "chapter-3.html#lý-thuyết",
    "href": "chapter-3.html#lý-thuyết",
    "title": "3  KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN",
    "section": "",
    "text": "Cấu trúc một chương trình C đơn giản\n\nKhai báo thư viện\nKhai báo biến toàn cục\nChương trình chính (main)\n\n\nMột chương trình đơn giản\n// Khai báo thư viện\n#include &lt;stdio.h&gt;\n#include &lt;conio.h&gt;\n// Khai báo biến toàn cục\nint a, b;\n// Chương trình chính\nvoid main()\n{\n    printf(\"Hello world!\");\n    getch();\n}\n\n\n\nCác kiểu dữ liệu cơ bản trong C\n\nKiểu số nguyên\n\n\n\nTên kiểu\nkích thước (byte)\n\n\n\n\nchar\n1\n\n\nunsigned char\n1\n\n\nint\n4\n\n\nunsigned int\n4\n\n\nlong\n8\n\n\nunsigned long\n8\n\n\n\n\n\nKiểu số thực\n\n\n\nTên kiểu\nkích thước (byte)\n\n\n\n\nfloat\n4\n\n\ndouble\n8\n\n\n\n\n\nKiểu ký tự\n\n\n\nTên kiểu\nkích thước (byte)\n\n\n\n\nchar\n1\n\n\nunsigned char\n1\n\n\n\n\n\nKiểu luận lý\n\n\n\nTên kiểu\nkích thước (byte)\n\n\n\n\nbool\n1\n\n\n\n\n\n\nCác phép toán\n\nPhép toán số học\n\n\n\nPhép toán\nC\nVí dụ\n\n\n\n\nCộng\n+\na+b\n\n\nTrừ\n-\na-b\n\n\nNhân\n*\na*b\n\n\nChia\n/\na/b\n\n\nDư\n\n\n\n\n\n\n\nphép toán so sánh\n\n\n\nPhép toán\nC\nVí dụ\n\n\n\n\nLớn hơn\n&gt;\na&gt;b\n\n\nNhỏ hơn\n&lt;\na&lt;b\n\n\nBằng\n==\na==b\n\n\nKhác\n!=\na!=b\n\n\nLớn hơn hoặc bằng\n&gt;=\na&gt;=b\n\n\nNhỏ hơn hoặc bằng\n&lt;=\na&lt;=b\n\n\n\n\n\nphép toán logic\n\n\n\nPhép toán\nC\nVí dụ\n\n\n\n\nphủ định\n!\n!a\n\n\nvà\n&&\na&&b\n\n\nhay\n||\na||b\n\n\n\n\n\nphép toán thao tác trên bit\n\n\n\nPhép toán\nC\nVí dụ\n\n\n\n\nNOT\n~\n~a\n\n\nAND\n&\na&b\n\n\nOR\n|\na\\|b\n\n\nXOR\n^\na^b\n\n\nSHIFT LEFT\n&lt;&lt;\na&lt;&lt;b\n\n\nSHIFT RIGHT\n&gt;&gt;\na&gt;&gt;b\n\n\n\n\n\nphép toán tăng giảm\n\n\n\nPhép toán\nC\nVí dụ\n\n\n\n\nTăng biến một đơn vị\n++\na++ hoặc ++a\n\n\nGiảm biến một đơn vị\n--\na-- hoặc --a\n\n\n\n\n\nphép toán gán và gán mở rộng\n\n\n\nPhép toán\nC\nVí dụ\n\n\n\n\nGán biến một giá trị\n=\na=b\n\n\n\n\ntoán tử điều kiện\n\n\n\nPhép toán\nC\nVí dụ\n\n\n\n\nđiều kiện\n?:\na?b:c\n\n\n\n\n\n\nđộ ưu tiên và kết hợp của các toán tử\n\n\n\n\n\n\n\n\nLoại\nToán tử\nKết hợp\n\n\n\n\nPostfix\n() [] -&gt;. ++ --\ntrái sang phải\n\n\nUnary\n+ - ! ~ ++ -- (type)* & sizeof\nphải sang trái\n\n\nMultiplicative\n* / %\ntrái sang phải\n\n\nAdditive\n+ -\ntrái sang phải\n\n\nShift\n&lt;&gt;\ntrái sang phải\n\n\nRelational\n&lt; &lt;= &gt; &gt;=\ntrái sang phải\n\n\nEquality\n== !=\ntrái sang phải\n\n\nBitwise AND\n&\ntrái sang phải\n\n\nBitwise XOR\n^\ntrái sang phải\n\n\nBitwise OR\n|\ntrái sang phải\n\n\nLogical AND\n&&\ntrái sang phải\n\n\nLogical OR\n||\ntrái sang phải\n\n\nConditional\n?:\nphải sang trái\n\n\nAssignment\n= += -= *= /= %= &gt;&gt;= &lt;&lt;= &= ^= |=\nphải sang trái\n\n\nComma\n,\ntrái sang phải\n\n\n\n\n\n\nCác hàm thư viện cơ bản\n\nThư viện xuất nhập chuẩn ”stdio.h”\n\n\nThư viện toán học ”math.h”\n\n\n\nTên hàm\nÝ nghĩa\n\n\n\n\nabs(x)\n|a|\n\n\nsin(x)\nsin(x)\n\n\ncos(x)\ncos(x)\n\n\npow(x,y)\nx^{y}\n\n\nsqrt(x)\n\\sqrt{x}\n\n\nlog(x)\nlog(x)\n\n\nexp(x)\ne^{x}\n\n\n\n\n\n\nCấu trúc tuần tự\n\n⟨lệnh 1⟩\n⟨lệnh 2⟩\n...\n⟨lệnh n⟩\nCác câu lệnh được thực hiện từ trên xuống, bắt đầu từ ⟨lệnh 1⟩, ⟨lệnh 2⟩ và cuối cùng là ⟨lệnh n⟩\n\n\nTính tổng hai số nguyên\n#include &lt;stdio.h&gt; \n#include &lt;conio.h&gt; \nvoid main() \n{ \n    int a, b, s;\n    printf(\"Nhap a va b = \"); \n    s = a + b;\n    printf(\"tong là = %d \", s);\n    getch();\n}\n\n\n\nCấu trúc rẽ nhánh\n\nCâu lệnh if\n\nif(⟨biểu thức điều kiện⟩) \n{ \n    ⟨khối lệnh⟩\n}\nNếu ⟨biểu thức điều kiện⟩ đúng thì thực hiện ⟨khối lệnh⟩. Lưu ý, ⟨biểu thức điều kiện⟩ phải được đặt trong cặp ngoặc\n\n\nKiểm tra một số có lớn hơn 6\n#include &lt;stdio.h&gt; \n#include &lt;conio.h&gt; \nvoid main() \n{ \n    float number;\n    printf(\"Nhap mot so trong khoang tu 1 den 10 = \"); \n    scanf(\"%f\", &number); \n    if(number&gt;6) \n        printf(\"So ban nhap lon hon 6. \\n\"); \n    printf(\"%f la so ban nhap. \", number); \n    getch();\n}\n\n\n\nCâu lệnh if … else\n\nif(⟨biểu thức điều kiện⟩) \n{ \n    ⟨khối lệnh 1⟩\n} \nelse \n{ \n    ⟨khối lệnh 2⟩\n} \nNếu ⟨biểu thức điều kiện⟩ cho kết quả đúng thì thực hiện ⟨khối lệnh 1⟩, ngược lại thì cho thực hiện ⟨khối lệnh 2⟩.\n\n\nGiải và biện luận phương trình ax+b=0\n#include &lt;stdio.h&gt; \n#include &lt;conio.h&gt; \nvoid main() \n{ \n    float a, b; \n    printf(\"Nhap vao a:\"); \n    scanf(\"%f\", &a); \n    printf(\"Nhap vao b:\"); \n    scanf(\"%f\", &b); \n    if(a==0) \n        if(b==0) printf(\"Phuong trinh vo so nghiem\"); \n        else printf(\"Phuong trinh vo nghiem\"); \n    else printf(\"Nghiem phuong trinh x=%f\", -b/a); \n    getch();\n}\n\n\n\nCâu lệnh switch\n\nswitch (⟨biểu thức số⟩) \n{ \n    case ⟨n_1⟩: ⟨các câu lệnh 1⟩  break; \n    case ⟨n_2⟩: ⟨các câu lệnh 2⟩  break; \n    ...\n    case ⟨n_k⟩: ⟨các câu lệnh k⟩  break; \n    [default: ⟨các câu lệnh k+1⟩] \n} \n\nKhi giá trị biểu thức bằng n_{i} thì thực hiện câu lệnh sau case ⟨n_i⟩.\nKhi giá trị biểu thức không thỏa tất cả các n_{i} thì thực hiện câu lệnh sau default nếu có, hoặc thoát khỏi câu lệnh switch.\nKhi chương trình đã thực hiện xong câu lệnh của case ⟨n_i⟩ nào đó thì nó sẽ thực hiện luôn các lệnh thuộc case bên dưới nó mà không xét lại điều kiện (do các n_i được xem như các nhãn) Vì vậy, để chương trình thoát khỏi lệnh switch sau khi thực hiện xong một trường hợp, ta dùng lệnh break.\n\n\n\nTạo thực đơn và cho phép chọn thực đơn bằng số nhập từ bàn phím.\n#include&lt;stdio.h&gt; \n#include&lt;conio.h&gt; \nvoid main()\n{ \n    int chon;\n    printf(\"Thuc Don\"); \n    printf(\"\\n1. Lau thai!\"); \n    printf(\"\\n2. Nuoc ngot!\"); \n    printf(\"\\n3. Ca loc hap bau!\"); \n    printf(\"\\n4. Chuot dong!\"); \n    printf(\"\\n Xin moi ban chon mon an!\"); \n    scanf(\"%d\",&chon); \n    switch(chon) \n    { \n        case 1: printf(\"\\nBan chon lau thai!\"); break; \n        case 2: printf(\"\\nBan chon nuoc ngot!\"); break; \n        case 3: printf(\"\\nBan chon ca loc hap bau!\"); break; \n        case 4: printf(\"\\Ban chon chuot dong!\"); break; \n        default: printf(\"\\nBan chon khong dung!\"); break;\n    } \n    getch(); \n} \n\n\n\n\nCấu trúc lặp\n\nCâu lệnh for\n\nfor(⟨biểu thức 1⟩; ⟨biểu thức 2⟩; ⟨biểu thức 3⟩) \n{ \n    ⟨các câu lệnh⟩ \n} \nHoạt động của câu lệnh for như sau:\n\nBước 1: Khởi gán cho ⟨biểu thức 1⟩\nBước 2: Kiểm tra điều kiện của ⟨biểu thức 2⟩\n\nNếu ⟨biểu thức 2⟩ đúng thì cho thực hiện ⟨các câu lệnh⟩ và thực hiện ⟨biểu thức 3⟩ rồi quay trở lại bước 2.\nNgược lại thì thoát khỏi lặp.\n\nBất kỳ biểu thức nào trong 3 biểu thức nói trên đều có thể vắng nhưng phải giữ dấu chấm phẩy (;)\n\n\n\nIn ra màn hình bảng mã ASCII từ ký tự số 32 đến 255.\n#include&lt;conio.h&gt; \n#include&lt;stdio.h&gt; \nvoid main() \n{ \n    for(int i=32;i&lt;=255;i++) \n        printf(\"Ma ASCII cua %c: %d\\t\", i, i); \n    getch(); \n}\n\n\n\nCâu lệnh while\n\nwhile(⟨biểu thức điều kiện⟩) \n{ \n    ⟨các câu lệnh⟩\n} \nNếu ⟨biểu thức điều kiện⟩ đúng thì thực hiện ⟨các câu lệnh⟩ và lặp điều này cho đến khi nào ⟨biểu thức điều kiện⟩ sai thì kết thúc\n\n\nIn ra các chữ số của số nguyên n\n#include&lt;stdio.h&gt; \n#include&lt;conio.h&gt; \nvoid main() \n{ \n    int n, chuso; \n    printf(\"Nhap vao n = \"); \n    scanf(\"%d\",&n); \n    while(n&gt;0) \n    { \n        chuso = n%10;\n        printf(\"%d \", chuso);\n        n = n/10; \n    }\n    getch(); \n} \n\n\n\nCâu lệnh do … while\n\ndo { \n    ⟨các câu lệnh⟩\n} while(⟨biểu thức điều kiện⟩);\nThực hiện khối lệnh cho đến khi ⟨biểu thức điều kiện⟩ có giá trị sai.\n\n\nNhập ký tự từ bàn phím hiển thị lên màn hình mã ASCII của ký tự đó, thực hiện đến khi nhấn phím ESC (Mã ASCII của phím ESC là 27).\n#include&lt;stdio.h&gt; \n#include&lt;conio.h&gt;\nvoid main() \n{ \n    int ma; \n    do{ \n        ma=getch(); \n        if(ma !=27) \n            printf(\"Ma ASCII %c:%d\\t\", ma, ma); \n    } while(ma!=27);\n    getch(); \n}\n\n\nLệnh lặp while kiểm tra điều kiện trước khi thực hiện lặp, còn lệnh lặp do...while thực hiện lệnh lặp rồi mới kiểm tra điều kiện. Do đó vòng lặp do...while thực hiện ⟨các câu lệnh⟩ ít nhất một lần.\n\n\n\nCâu lệnh break và continue\nLệnh break dùng để kết thúc vòng lặp trực tiếp chứa nó\n\nCho phép người dùng nhập liên tục giá trị n cho đến khi nhập số âm thì dừng lại\n#include&lt;stdio.h&gt; \n#include&lt;conio.h&gt; \nvoid main() \n{ \n    while(1) \n    { \n        printf(\"Nhap n = \"); \n        scanf(\"%d\", &n); \n        if(n&lt;0) break; \n    } \n    getch(); \n} \n\nLệnh continue dùng để bỏ qua một lần lặp.\n\nIn ra màn hình giá trị từ 1 đến 25 trừ đi số 14 và số 18.\n#include&lt;stdio.h&gt; \n#include&lt;conio.h&gt;\nvoid main() \n{ \n    for(int i=1; i&lt;=25; i++) \n    { \n        if(i==14||i==18) continue; \n        printf(\"%d\\t\", i); \n    } \n    getch();\n} \n\n\n\n\nCấu trúc nhảy\n\n⟨nhãn⟩:\n...\ngoto ⟨nhãn⟩\n...\ncon trỏ lệnh sẽ được nhảy đến vị trị của ⟨nhãn⟩\n\n\nKiểm tra một số nguyên là số dương, âm hay không?\n#include&lt;stdio.h&gt; \n#include&lt;conio.h&gt;\nvoid main() \n{ \n    int n;\n    printf(\"Nhap vao so nguyen = \");\n    scanf(\"%d\", &n);\n    if(n&gt;0) goto nhan1;\n    if(n&lt;0) goto nhan2;\n    if(n==0) goto nhan2;\nnhan1:\n    printf(\"so duong\");\n    goto nhan;\nnhan2:\n    printf(\"so am\");\n    goto nhan;\nnhan3:\n    printf(\"so khong\");\nnhan:\n    getch();\n} \n\n\n\nThực thi chương trình\n\nXác định các biến trong chương trình.\nGiá trị ban đầu của mỗi biến.\nThực hiện chạy chương trình theo đúng trình tự đã được viết\n\n\nCho biết kết quả của đoạn chương trình sau:\nvoid main() \n{ \n    int i, a = 4; \n    for(i = 0; i&lt;a; i++) \n        printf(\"%d\\n\", i); \n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN</span>"
    ]
  },
  {
    "objectID": "chapter-3.html#bài-tập",
    "href": "chapter-3.html#bài-tập",
    "title": "3  KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN",
    "section": "3.2 BÀI TẬP",
    "text": "3.2 BÀI TẬP\n\nBài tập cơ bản\n\n\nBiến, biểu thức và toán tử\n\nChuỗi ký tự nào sau đây không thể là tên biến được?\n\n\n\nBASICSALARY\n_basic\nbasic-hra\n\n\n#MEAN\ngroup.\n422\n\n\npopulation in 2006\nover time\nmindovermatter\n\n\nFLOAT\nhELLO\nqueue.\n\n\nteam'svictory\nPlot # 3\n2015_DDay\n\n\nnhiệt\nvan_toc\nlai suat\n\n\n\nChỉ ra biểu thức C/C++ lỗi (nếu có)\n\nint = 314.562 * 150;\nname = 'Ajay';\nvarchar = '3';\n3.14 * r * r * h = vol_of_cyl;\nk = ( a * b ) ( c + ( 2.5a + b ) ( d + e );\nm_inst = rate of interest * amount in rs;\nsi = principal * rateofinterest * numberofyears / 100;\narea = 3.14 * r ** 2;\nvolume = 3.14 * r ^ 2 * h;\nk = ( (a * b ) + c ) ( 2.5 * a + b );\na = b = 3 = 4;\ncount = count + 1;\ndate = '2 Mar 04';\n\nXác định thứ tự thực hiện các phép toán và tính giá trị của biểu thức\n\ng = big / 2 + big * 4 / big - big + abc / 3; (abc = 2.5, big = 2, giả sử g có kiểu float)\non = ink * act / 2 + 3 / 2 * act + 2 + tig; (ink = 4, act = 1, tig = 3.2, giả sử on có kiểu int)\ns = qui * add / 4 - 6 / 2 + 2 / 3 * 6 / god; (qui = 4, add = 2, god = 2, giả sử s có kiểu int)\ns = 1 / 3 * a / 4 - 6 / 2 + 2 / 3 * 6 / g; (a = 4, g = 3, giả sử s có kiểu int)\n\nXác định toán hạng cho các phép toán trong biểu thức\n\ng = 10 / 5 / 2 / 1;\nb = 3 / 2 + 5 * 4 / 3;\na = b = c = 3 + 4;\n\nChuyển các biểu thức toán sau sang ngôn ngữ C/C++\nA=\\frac{\\frac{8.8(a+b)2}{c}-0.5+\\frac{2a}{q+r}}{\\frac{a+b}{m}}\nB=\\frac{-b+b^{2}+2.4ac}{2a}\nC=\\frac{2v+6.22(c+d)}{g+v}\nD=\\frac{\\frac{7.7b(xy+a)}{c}-0.8+2b}{\\frac{x+a}{y}}\n\n\n\nCấu trúc rẽ nhánh\n\nCho biết kết quả của đoạn chương trình sau:\nint a=9, b=6; \na++; \na=a+b--; \na=a+(--b); \nif(a%2==0) printf(\"Gia tri cua a la chan\"); \nprintf(\"Tong cua a va b la: %d\", a+b); \nCho biết kết quả của đoạn chương trình sau:\nint a=7, b=8; \na++; \na=a+(b--); \n--b; \na--; \na=(--a)+(--b); \nif(a%2!=0) \n    printf(\"\\n a la so le\"); \nelse \n    printf(\"\\n a la so chan\"); \nprintf(\"\\na = %d\",a); \nCho biết kết quả của đoạn chương trình sau:\nint x=5, y; \ny=x++ + 5; \nprintf(\"x=%d, y=%d\\n\", x, y); \ny*=6; \nx=y%7; \nprintf(\"x=%d,y=%d,y/x=%d\", x, y, y/x); \nNhập vào hai số nguyên a,b. In ra màn hình giá trị lớn nhất.\nCho ba số a,b,c đọc vào từ bàn phím. Hãy tìm giá trị lớn nhất của ba số trên và in ra kết quả.\nCho ba số a,b,c đọc vào từ bàn phím. Hãy in ra màn hình theo thứ tự tăng dần các số. (Chỉ được dùng thêm hai biến phụ).\nViết chương trình nhập vào một số nguyên n gồm ba chữ số. Xuất ra màn hình chữ số lớn nhất ở vị trí nào? Ví dụ: n=291. Chữ số lớn nhất nằm ở hàng chục là 9.\nViết chương trình nhập vào số nguyên n gồm ba chữ số. Xuất ra màn hình theo thứ tự tăng dần của các chữ số. Ví dụ: n=291. Xuất ra 129.\nNhập vào ngày, tháng, năm. Kiểm tra xem ngày, tháng, năm đó có hợp lệ hay không? In kết quả ra màn hình.\nNhập vào giờ, phút, giây. Kiểm tra xem giờ, phút, giây đó có hợp lệ hay không? In kết quả ra màn hình.\nViết chương trình nhập vào ngày, tháng, năm hợp lệ. Cho biết năm này có phải là năm nhuận hay không? In kết quả ra màn hình.\nViết chương trình tính diện tích và chu vi các hình: tam giác, hình vuông, hình chữ nhật và hình tròn với những thông tin cần được nhập từ bàn phím.\nViết chương trình tính tiền cước TAXI. Biết rằng:\n\nkm đầu tiên giá là 5000đ\n200m tiếp theo là 1000đ.\nNếu lớn hơn 30km thì mỗi km thêm sẽ là 3000đ\n\nHãy nhập số km sau đó in ra số tiền phải trả.\nNhập vào 3 số nguyên dương a,b,c. Kiểm tra xem 3 số đó có lập thành tam giác không? Nếu có hãy cho biết tam giác đó thuộc loại nào? (cân, vuông, đều, …).\nViết chương trình nhập vào số nguyên dương n. Kiểm tra xem n có phải là số chính phương hay không? (số chính phương là số khi lấy căn bặc 2 có kết quả là nguyên).\n\n\n\nCấu trúc lặp\n\nCho biết kết quả của đọan chương trình sau:\nint a=18; \nfor(int i=1; i&lt;=a; i++) \n    if(a%i==0) printf(\"\\t %d\", i); \nCho biết kết quả của đọan chương trình sau:\nfor(int i=0; i&lt;5; i++) \n{ \n    for(int j=0; j&lt;=i; j++) \n        printf(\"%d\\t\", j); \n    printf(\"\\n\"); \n} \nCho biết kết quả của đọan chương trình sau:\nint i=10, s=0; \nwhile(i&gt;0) \n{ \n    if(i%2==0) \n        s+=i; \n    else \n        if(i&gt;5) \n            s+=2*i; \n    i--; \n} \nprintf(\"s = %d\",s); \nCho biết kết quả của đọan chương trình sau:\nint a=18, i=1; \ndo{ \n    if(a%i==0) \n    printf(\"\\t %d\",i); \n    i++; \n} while(i&lt;=a); \nCho biết kết quả của đọan chương trình sau:\nint a=11, b=16, i=a; \nwhile(i&lt;b) \n{ \n    if(i%2==0) \n    { \n        printf(\"\\t %d\", i); \n        break; \n    } \n    i++; \n} \nCho biết kết quả của đọan chương trình sau:\nint a=10, s=0, i=0; \nwhile(i&lt;a) \n{ \n    i++; \n    if(i%2==0) \n        continue; \n    else \n        s=s+i; \n} \nprintf(\"s=%d\",s); \nCho biết kết quả của đọan chương trình sau:\nint i=1,s=0; \nwhile(1) \n{ \n    s=s+i++; \n    if(i%2) \n        i=i+2; \n    else \n        i=i+1; \n    if(i&gt;20) break; \n} \nprintf(\"%d\",s); \nViết chương trình in ra màn hình hình chữ nhật đặc kích thước m\\times n. Ví dụ: Nhập m=5,n=4\n* * * * \n* * * * \n* * * * \n* * * * \n* * * *\nViết chương trình in ra màn hình hình chữ nhật rỗng kích thước m\\times n. Ví dụ: Nhập m=5,n=4\n* * * * \n*     * \n*     * \n*     * \n* * * *\nViết chương trình in ra màn hình tam giác vuông cân đặc có độ cao h. Ví dụ: Nhập h=4\n* \n* * \n* * * \n* * * * \nViết chương trình in ra màn hình tam giác cân rỗng có độ cao h. Ví dụ: Nhập h=4\n* \n* * \n*   * \n* * * * \nViết chương trình in ra màn hình tam giác cân đặc có độ cao h. Ví dụ: Nhập h=4\n      *\n    * * *\n  * * * * *\n* * * * * * * \nViết chương trình in ra màn hình tam giác cân rỗng có độ cao h. Ví dụ: Nhập h=4\n      *\n    *   *\n  *       *\n* * * * * * *\nViết chương trình nhập số nguyên dương n. Liệt kê n số nguyên tố đầu tiên.\nViết chương trình nhập vào hai số nguyên dương a và b. Tìm ước số chung lớn nhất và bội số chung nhỏ nhất của a và b.\nViết chương trình nhập vào một số nguyên n gồm tối đa 10 chữ số (4 bytes). In ra màn hình giá trị nhị phân của số trên.\nViết chương trình đếm số ước số của số nguyên dương n. Ví dụ: n=12 số ước số của 12 là 6\nMột số hoàn thiện là một số có tổng các ước số của nó (không kể nó) bằng chính nó. Hãy liệt kê các số hoàn thiện nhỏ hơn 5000. Ví dụ: số 6 là số hòan thiện vì tổng các ước số là 1+2+3=6.\nNhập vào ngày, tháng, năm. Cho biết đó là ngày thứ mấy trong năm.\nIn ra dãy số Fibo f_{n} f_{n}=\\begin{cases}\n1 & n=1\\\\\n1 & n=2\\\\\nf_{n-1}+f_{n-2} & n&gt;2\n\\end{cases}\n\n\n\nBài tập luyện tập và nâng cao\n\nCài đặt tất cả các lưu đồ đã vẽ ở chương 1.\nNhập vào ngày, tháng, năm. Kiểm tra xem ngày, tháng, năm đó có hợp lệ hay không, nếu hợp lệ cho biết ngày sau đó là bao nhiêu. Ví dụ: Nhập 31/12/2003 Ngày sau đó 01/01/2004\nNhập vào ngày, tháng, năm. Kiểm tra xem ngày, tháng, năm đó có hợp lệ hay không, nếu hợp lệ cho biết ngày trước đó là bao nhiêu. Ví dụ: Nhập 01/01/2003 Ngày trước đó 31/12/2002\n(*) Nhập vào ngày, tháng, năm của năm 2003. Hãy kiểm tra xem dữ liệu có hợp lệ hay không? Nếu hợp lệ hãy cho biết đó là ngày thứ mấy trong tuần. (hai, ba, tư, …, CN).(Hướng dẫn: lấy ngày 01 tháng 01 năm 2003 là ngày thứ tư làm mốc).\nNhập vào giờ, phút, giây. Kiểm tra xem giờ, phút, giây đó có hợp lệ hay không, nếu hợp lệ cho biết giờ sau đó 1 giây là bao nhiêu. Ví dụ: Nhập 01:59:59 Giờ sau đó 1 giây 02:00:00\nNhập vào giờ, phút, giây. Kiểm tra xem giờ, phút, giây đó có hợp lệ hay không, nếu hợp lệ cho biết giờ trước đó 1 giây là bao nhiêu. Ví dụ: Nhập 02:00:00 Giờ trước đó 1 giây 01:59:59\nViết chương trình in ra bảng cửu chương từ 2 đến 9.\n(*) Vẽ hình cánh quạt sau với h là chiều dài cánh quạt. Ví dụ h=4\n*     * * * *\n* *   * * *    \n* * * * *\n* * * * * * *\n    * * * * * \n  * * *   * *\n* * * *     *",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN</span>"
    ]
  },
  {
    "objectID": "chapter-3.html#tóm-tắt",
    "href": "chapter-3.html#tóm-tắt",
    "title": "3  KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN",
    "section": "3.3 TÓM TẮT",
    "text": "3.3 TÓM TẮT\nCấu tuần tự, trúc lặp và rẽ nhánh (lựa chọn) là ba cấu trúc chính hình thành nên chương trình. Dựa vào những cấu trúc điều khiển này ta có thể xây dựng thành những chương trình phức tạp hơn. Vì vậy phải nắm rõ cách hoạt động của những cấu trúc điều khiển này để cài đặt đúng yêu cầu bài toán. Khi sử dụng phải lưu ý điều kiện thực hiện hay kết thúc của một thao tác nào đó. Bên trong một phát biểu điều khiển phải là một lệnh hay một khối lệnh (khối lệnh được đặt bên trong cặp dấu ngoặc {}). Những biến không phụ thuộc vào vòng lặp nên đặt bên ngoài vòng lặp. Khi sử dụng cấu trúc điều khiển lồng nhau phải lưu ý vị trí mở ngoặc hay đóng ngoặc cho hợp lý.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CƠ BẢN VÀ CẤU TRÚC ĐIỀU KHIỂN</span>"
    ]
  },
  {
    "objectID": "chapter-4.html",
    "href": "chapter-4.html",
    "title": "4  HÀM",
    "section": "",
    "text": "4.1 LÝ THUYẾT\nChương này trình bày cấu trúc của một chương trình, các bước xây dựng cài đặt chương trình theo phương pháp thủ tục hàm và một số kỹ thuật liên quan.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>HÀM</span>"
    ]
  },
  {
    "objectID": "chapter-4.html#lý-thuyết",
    "href": "chapter-4.html#lý-thuyết",
    "title": "4  HÀM",
    "section": "",
    "text": "Khái niệm\nHàm là một đoạn chương trình độc lập thực hiện trọn vẹn một công việc nhất định sau đó trả về giá trị cho chương trình gọi nó, hay nói cách khác hàm là sự chia nhỏ của chương trình. Hàm được sử dụng khi\n\nCó một công việc giống nhau cần thực hiện ở nhiều lúc khác nhau.\nKhi cần chia một chương trình lớn phức tạp thành các chương trình nhỏ để dễ quản lý việc tính toán và giải quyết vấn đề cũng như dễ hiểu.\n\n\nMột chương trình có sử dụng hàm đơn giản\n// Khai báo thư viện\n#include &lt;stdio.h&gt;\n#include &lt;conio.h&gt;\n// Khai báo biến toàn cục\nfloat x,y;\nint n;\n// Khai báo hàm\nfloat LuyThua(float x, int n);\n// Hàm chính\nvoid main()\n{\n    printf(\"Nhap x va n =\");\n    scanf(\"%f%d\", &x, &n);\n    y = LuyThua(x, n);\n}\n// Cài đặt hàm\nfloat LuyThua(float x, int n)\n{\n    float y = 1;\n    for(int i=1; i&lt;=n; i++)\n        y = y*x;\n    return y;\n}\n\n\n\nCấu trúc một chương trình C\n\nPhần khai báo\nBao gồm các\n\nKhai báo thư viện sử dụng\nKhai báo hằng số\nKhai báo kiểu dữ liệu tự định nghĩa\nKhai báo các biến toàn cục\nKhai báo các hàm hay nguyên mẫu hàm\n\n\n\nHàm chính main\nThực hiện các công việc và các lời gọi hàm cần thiết.\n\n\nCác hàm\nThực hiện các công việc xác định.\n\n\n\nCách xây dựng một hàm con\n\nKhai báo hàm\n\n⟨Kiểu dữ liệu trả về của hàm⟩ ⟨Tên hàm⟩(⟨danh sách các tham số⟩);\nLưu ý tham số trong nguyên mẫu hàm có thể bỏ phần tên.\n\n\n\nCài đặt hàm\n\n⟨Kiểu dữ liệu trả về của hàm⟩ ⟨Tên hàm⟩(⟨danh sách các tham số⟩)\n{\n    ⟨các câu lệnh⟩\n}\n\n\n\nGọi hay thực thi hàm\n\n⟨Tên hàm⟩(⟨danh sách các tham số được truyền⟩);\n\nCó 3 cách truyền tham số:\n\nTruyền bằng giá trị\n\nTham số gọi là tham trị\nTruyền đối số cho hàm ở dạng giá trị.\nCó thể truyền hằng, biến, biểu thức.\nĐược sử dụng khi không có nhu cầu thay đổi giá trị của tham số sau khi thực hiện hàm.\n\nvoid Ham(int x)\n{\n    ...\n    y = x;\n    ...\n}\nvoid main()\n{\n    int a, b;\n    ...\n    Ham(3);\n    Ham(a);\n    Ham(a+b);\n    ...\n}\nTruyền bằng địa chỉ\n\nTham số gọi là tham trỏ\nTruyền đối số cho hàm ở dạng địa chỉ (con trỏ).\nChỉ truyền đối số là biến.\nĐược sử dụng khi có nhu cầu thay đổi hoặc nhận giá trị của đối số sau khi thực hiện hàm.\n\nvoid Ham(int *x)\n{\n    ...\n    y = *x;\n    ...\n}\nvoid main()\n{\n    int a;\n    ...\n    Ham(&a);\n    ...\n}\nTruyền bằng tham chiếu\n\nTham số gọi là tham biến\nTruyền đối số cho hàm ở dạng tham chiếu.\nChỉ truyền đối số là biến.\nĐược sử dụng khi có nhu cầu thay đổi hoặc nhận giá trị của đối số sau khi thực hiện hàm.\n\nvoid Ham(int &x)\n{\n    ...\n    y = x;\n    ...\n}\nvoid main()\n{\n    int a;\n    ...\n    Ham(a);\n    ...\n}\n\n\n\nXác định kiểu dữ liệu trả về của hàm\nXác định dựa vào đầu ra của hàm. Gồm 2 loại:\n\nHàm không trả về giá trị: Những hàm loại này thường rơi vào những nhóm chức năng: nhập/xuất dữ liệu, thống kê, sắp xếp, liệt kê.\n\nvoid ⟨Tên hàm⟩(⟨danh sách các tham số⟩)\n{ \n    ⟨Khai báo các biến cục bộ⟩\n    ⟨Các câu lệnh hay lời gọi hàm⟩\n}\n\nHàm trả về kiểu dữ liệu cơ bản hay kiểu dữ liệu có cấu trúc: Kiểu dữ liệu tùy theo mục đích của hàm cần trả về giá trị gì thông qua việc phân tích bài toán. Những hàm loại này thường được sử dụng trong các trường hợp: Đếm, kiểm tra, tìm kiếm, tính trung bình, tổng, tích, …\n\n⟨Kiểu dữ liệu⟩ ⟨Tên hàm⟩(⟨danh sách các tham số⟩)\n{ \n    ⟨Kiểu dữ liệu⟩ kq; \n    ⟨Khai báo các biến cục bộ⟩ \n    ⟨Các câu lệnh hay lời gọi hàm⟩\n    return kq; \n}\n\n\nĐối với những hàm trả về nhiều loại giá trị cho từng trường hợp cụ thể (chẳng hạn như kiểm tra: đúng hay sai, so sánh: bằng, lớn hơn hay nhỏ hơn, …) thì cần ghi chú rõ giá trị trả về là gì cho từng trường hợp đó.\n\n\nXác định tham số\nXác định dựa vào đầu vào của hàm. Lưu ý\n\nTham số dạng tham trị: Không thay đổi hoặc không cần lấy giá trị mới của tham số sau lời gọi hàm. Tham số dạng này chỉ mang ý nghĩa là dữ liệu đầu vào.\nTham số dạng tham trỏ và tham biến: Có sự thay đổi giá trị của tham số trong quá trình thực hiện và cần lấy lại giá trị đó sau khi ra khỏi hàm. Ứng dụng của tham số loại này có thể là dữ liệu đầu ra (kết quả) hoặc cũng có thể vừa là dữ liệu đầu vào vừa là dữ liệu đầu ra.\n\n\n\nXác định biến cục bộ\nLà các đại lượng trung gian được sử dụng trong hàm\n\n\nXác định tên hàm\nĐặt tên theo quy ước đặt tên trong C sao cho tên gọi đúng với chức năng hay mục đích thực hiện của hàm và gợi nhớ.\n\n\nCác ví dụ\n\nViết hàm in ra màn hình các ước số của n\nPhân tích hàm:\n\nInput: n là số nguyên dương\nOutput: không có\nCông việc: In ra các ước số của số của n\n\nvoid LietKeUocSo(unsigned int n) \n{ \n    for(int i=1; i&lt;=n; i++) \n        if(n%i == 0)\n            printf(\"%u\\t\", i); \n} \n\n\nViết hàm tính tổng S(n)=1+2+3+\\ldots+n, với n là số nguyên dương\nPhân tích bài toán:\n\nInput: n là số nguyên dương\nOutput: S là tổng của 1+2+3+...+n\nCông việc: Tính tổng S\n\nunsigned int TongS(unsigned int n) \n{ \n    unsigned int S=0; \n    int i=1; \n    while(i&lt;=n) \n    { \n        S+=i; \n        i++; \n    } \n    return S; \n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>HÀM</span>"
    ]
  },
  {
    "objectID": "chapter-4.html#bài-tập",
    "href": "chapter-4.html#bài-tập",
    "title": "4  HÀM",
    "section": "4.2 BÀI TẬP",
    "text": "4.2 BÀI TẬP\n\nBài tập cơ bản\n\nCài đặt lại tất cả các bài tập ở chương 2 theo phương pháp hàm.\nViết chương trình tính diện tích và chu vi của hình chữ nhật với chiều dài và chiều rộng được nhập từ bàn phím.\nViết chương trình tính diện tích và chu vi hình tròn với bán kính được nhập từ bàn phím.\nNhập số nguyên dương n. Liệt kê tất cả các số nguyên tố nhỏ hơn n.\nNhập số nguyên dương n. Liệt kê n số chính phương đầu tiên.\nNhập số nguyên dương n. Đếm xem có bao nhiêu số hoàn thiện nhỏ hơn n.\nNhập số nguyên dương n (0&lt;n&lt;1000) và in ra cách đọc của n. Ví dụ: Nhập n = 105. In ra màn hình: mot tram le nam.\nViết chương trình tính tiền thuê máy dịch vụ Internet và in ra màn hình kết quả. Với dữ liệu nhập vào là giờ bắt đầu thuê (GBD), giờ kết thúc thuê (GKT), số máy thuê (SoMay).\n\nĐiều kiện cho dữ liệu nhập: 6\\leqGBD&lt;GKT\\leq21. Giờ là số nguyên.\nĐơn giá: 2500đ cho mỗi giờ máy trước 17:30 và 3000đ cho mỗi giờ máy sau 17:30.\n\nViết chương trình tính tiền lương ngày cho công nhân, cho biết trước giờ vào ca, giờ ra ca của mỗi người. Giả sử rằng:\n\nTiền trả cho mỗi giờ trước 12 giờ là 6000đ và sau 12 giờ là 7500đ.\nGiờ vào ca sớm nhất là 6 giờ sáng và giờ ra ca trễ nhất là 18 giờ (Giả sử giờ nhập vào nguyên).\n\nNhập vào 2 số nguyên p,q và tính biểu thức sau: \\left(-\\frac{q}{2}+\\left(\\frac{p^{3}}{27}+\\frac{q^{2}}{4}\\right)^{\\frac{1}{2}}\\right)^{\\frac{1}{3}}+\\left(-\\frac{q}{2}-\\left(\\frac{p^{3}}{27}+\\frac{q^{2}}{4}\\right)^{\\frac{1}{2}}\\right)^{\\frac{1}{3}}\nNhập vào 3 số thực a,b,c và kiểm tra xem chúng có thành lập thành 3 cạnh của một tam giác hay không? Nếu có hãy tính diện tích, chiều dài mỗi đường cao của tam giác và in kết quả ra màn hình.\n\nCông thức tính diện tích s=\\sqrt{(p*(p-a)*(p-b)*(p-c))} với p là nữa chu vi của tam giác\nCông thức tính các đường cao: h_{a}=\\frac{2s}{a},h_{b}=\\frac{2s}{b},h_{c}=\\frac{2s}{c}\n\nNhập vào 6 số thực a,b,c,d,e,f. Giải hệ phương trình sau: \\left\\{ \\begin{array}{l}\nax+by=c\\\\\ndx+ey=f\n\\end{array}\\right.\nViết chương trình nhập 2 số nguyên dương a,b. Tìm USCLN và BSCNN của hai số nguyên đó.\nViết chương trình tính tổng nghịch đảo của n giai thừa.\nCho 2 số nguyên a,b. Viết hàm hoán vị giá trị 2 số trên.\n(*) Viết chương trình nhập số nguyên dương n gồm 5 chữ số, kiểm tra xem các chữ số n có phải là số đối xứng hay không. Ví dụ: Đối xứng: 13531 Không đối xứng: 13921\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, đếm xem n có bao nhiêu chữ số chẵn và bao nhiêu chữ số lẻ.\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, đếm xem n có bao nhiêu chữ số là số nguyên tố.\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, tính tổng các ước số dương của n. Ví dụ, nhập n=6 Tổng các ước số từ 1 đến n: 1+2+3+6=12.\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, tìm ước số lẻ lớn nhất của n. Ví dụ: Ước số lẻ lớn nhất của 27 là\n\n\n\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, kiểm tra xem các chữ số của n có toàn lẻ hay toàn chẵn không.\n(*) Viết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, sắp xếp các chữ số của n theo thứ tự tăng dần. Ví dụ: Nhập n=1536 Kết quả sau khi sắp xếp: 1356.\n\n\n\nBài tập luyện tập và nâng cao\n\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, sau đó nhập một số nguyên x, tìm vị trí xuất hiện của chữ số có giá trị x trong n. Ví dụ: Nhập n=1526, x=2 Kết quả: Chu so 2 o vi tri thu 3.\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, kiểm tra xem các chữ số của n có được sắp thứ tự không. Ví dụ, nhập n=1569 hoặc n=8521 thì kết quả là có thứ tự.\nViết chương trình nhập 2 số a,b sao cho: số lớn nhất trong 2 số phải là một số dương và chia hết cho 7. Nếu nhập sai phải yêu cầu nhập lại cho đến khi đúng.\nViết chương trình nhập số nguyên dương n gồm k chữ số, k\\leq5, tính giá trị trung bình các chữ số chẵn trong n.\n(*) Viết chương trình in ra màn hình ngày/tháng/năm của ngày hiện tại, cho phép sử dụng các phím mũi tên lên, xuống để tăng hoặc giảm một ngày.\n(*) Viết chương trình in ra màn hình giờ:phút:giây hiện tại, cho phép sử dụng các phím mũi tên lên, xuống để tăng hoặc giảm một giây.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>HÀM</span>"
    ]
  },
  {
    "objectID": "chapter-4.html#tóm-tắt",
    "href": "chapter-4.html#tóm-tắt",
    "title": "4  HÀM",
    "section": "4.3 TÓM TẮT",
    "text": "4.3 TÓM TẮT\nTrước khi xây dựng một hàm ta phải xác định mục đích của hàm là dùng để làm gì, trên cơ sở đó, ta mới xác định được các thành phần của hàm và xây dựng nguyên mẫu hàm. Mỗi hàm phải thực hiện một chức năng độc lập và tách biệt với các hàm khác (không được lồng nhau). Đối với hàm có giá trị trả về phải lưu ý kiểu dữ liệu phải tương ứng kiểu dữ liệu cả giá trị trả về và kiểu dữ liệu của biến được gán khi gọi hàm. Trường hợp hàm trả về từ hai loại giá trị trở lên thì phải có dòng chú thích cho trường hợp tương ứng để khi gọi hàm biết được kết quả (chẳng hạn như tìm kiếm, kiểm tra, so sánh,.v.v giá trị trả về có 2 trường hợp: có hoặc không có phần tử cần tìm, thỏa điều kiện kiểm tra hay không? Do vậy ta phải quy ước giá trị cho từng trường hợp). Nên đặt tên hàm sao cho gợi nhớ được chức năng, đặt tên theo quy tắc nhất định để tránh việc gọi sai tên hàm do lẫn lộn giữa ký tự hoa và thường, có dấu gạch nối giữa các từ trong hàm hay không? Khi gọi hàm phải truyền đủ tham số, đúng kiểu dữ liệu và đúng thứ tự của tham số.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>HÀM</span>"
    ]
  },
  {
    "objectID": "chapter-5.html",
    "href": "chapter-5.html",
    "title": "5  KIỂU DỮ LIỆU MẢNG MỘT CHIỀU",
    "section": "",
    "text": "5.1 LÝ THUYẾT\nChương này trình bày trình bày dữ liệu kiểu mảng, các thao tác nhập xuất, các kỹ thuật thao tác trên mảng. Ứng dụng các kỹ thuật này trong việc cài đặt các hàm tìm kiếm, kiểm tra, xây dựng mảng, tách và ghép mảng.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG MỘT CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-5.html#lý-thuyết",
    "href": "chapter-5.html#lý-thuyết",
    "title": "5  KIỂU DỮ LIỆU MẢNG MỘT CHIỀU",
    "section": "",
    "text": "mảng một chiều là tập hợp các phần tử được lưu trữ liên tục và các phần tử của mảng phải cùng kiểu dữ liệu.\n\n\nKhai báo biến mảng\n\n⟨Kiểu dữ liệu⟩ ⟨Tên mảng⟩ [⟨Số phần tử tối đa của mảng⟩];\n\n\nKhai báo mảng a có 100 số nguyên và mảng b có 50 số thực\nint a[100]; \nfloat b[50]; \n\n\n\nTruy xuất phần tử của mảng\nVới khái niệm và cách khai báo như trên ta có hình dạng của mảng một chiều như sau:\n\n⟨Tên mảng⟩[⟨Chỉ số⟩]\n\n\nKhởi tạo và xuất mảng một chiều\n#include &lt;conio.h&gt; \n#include &lt;stdio.h&gt; \nvoid main() \n{ \n    int a[4] = {5,9,3,8}; \n    for(int i = 0; i &lt; 4; i++) \n        printf(\" a [ %d ] = %d \\t\", i, a[i]); \n    getch(); \n}",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG MỘT CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-5.html#bài-tập",
    "href": "chapter-5.html#bài-tập",
    "title": "5  KIỂU DỮ LIỆU MẢNG MỘT CHIỀU",
    "section": "5.2 BÀI TẬP",
    "text": "5.2 BÀI TẬP\n\nKỹ thuật nhập xuất mảng một chiều\n\nViết chương trình nhập xuất mảng một chiều các số nguyên.\n#include &lt;conio.h&gt; \n#include &lt;stdio.h&gt; \n#define MAX 100\nvoid NhapMang(int a[], int &n) \n{ \n    printf(\"Nhap so phan tu: \"); \n    scanf(\" %d \", &n); \n    for(int i = 0; i &lt; n; i ++) \n    { \n        printf(\" a [%d] = \", i); \n        scanf(\" %d \", &a[i]); \n    } \n}\nvoid XuatMang(int a[], int n) \n{ \n    printf(\"\\nNoi dung mang: \"); \n    for(int i = 0; i &lt; n; i ++) \n        printf(\" %d \\t \", a[i]); \n}\nvoid main() \n{ \n    int a[MAX], n; \n    NhapMang(a,n); \n    XuatMang(a,n); \n    getch(); \n}\n\n\nViết chương trình nhập xuất mảng một chiều các số thực.\nViết chương trình khởi tạo giá trị các phần tử là 0 cho mảng một chiều các số nguyên gồm n phần tử.\nViết chương trình phát sinh ngẫu nhiên mảng một chiều các số nguyên âm.\nViết chương trình phát sinh ngẫu nhiên mảng một chiều các số nguyên sao cho mảng có thứ tự tăng dần (không sắp xếp).\nViết chương trình nhập mảng các số thực và xuất các phần tử âm trong mảng.\nViết chương trình nhập mảng các số nguyên và xuất các phần tử lẻ có trong mảng.\nViết chương trình nhập vào mảng một chiều các số nguyên và xuất ra các phần tử chẵn nhỏ hơn 20.\nViết chương trình nhập vào mảng một chiều các số nguyên và xuất ra màn hình các phần tử là số nguyên tố.\nViết chương trình nhập vào số nguyên n và liệt kê các số nguyên tố nhỏ hơn n, nếu mảng không tồn tại số nguyên tố nào nhỏ hơn n thì phải xuất ra một câu thông báo.\nViết chương trình nhập vào mảng một chiều các số nguyên và xuất ra màn hình các phần tử là số chính phương nằm tại những vị trí lẻ trong mảng.\n\n\n\nKỹ thuật đặt cờ hiệu\nKỹ thuật này thường được áp dụng cho những bài toán kiểm tra hay đánh dấu.\n\nViết hàm kiểm tra xem mảng các số nguyên có thứ tự tăng dần không? (Trả về 1: Nếu mảng tăng dần, ngược lại trả về 0).\nint KiemTraTang(int a[], int n) \n{ \n    int flag = 1; \n    for(int i = 0; i &lt; n-1; i ++) \n        if(a[i] &gt; a[i+1]) // vi phạm điều kiện tăng dần\n        { \n            flag = 0; \n            break; \n        } \n    return flag; \n} \n\n\nViết hàm kiểm tra xem trong mảng các số nguyên có tồn tại số nguyên lẻ lớn hơn 100 hay không? (Trả về 1: Nếu có tồn tại số lẻ và lớn hơn 100, ngược lại trả về 0).\nint KiemTraLe(int a[], int n) \n{ \n    int flag = 0; \n    for(int i = 0; i &lt; n; i ++) \n        if(a[i] % 2 != 0 && a[i][j] &gt; 100) // Gặp phần tử thoả\n        { \n            flag = 1; \n            break; \n        } \n    return flag; \n} \n\n\n\nKỹ thuật đặt lính canh\nKỹ thuật này thường được áp dụng cho những bài tập về tìm kiếm, liệt kê theo một điều kiện nhất định nào đó.\n\nViết hàm tìm và trả về giá trị lớn nhất trong mảng một chiều các số nguyên.\nint TimMax(int a[], int n) \n{ \n    int max, i = 1;\n    max = a[0]; \n    while(i &lt; n) \n    { \n        if(a[i] &gt; max) max = a[i]; \n        i++; \n    } \n    return max; \n} \n\n\n\nKỹ thuật tìm kiếm trên mảng một chiều\n\nViết hàm tìm phần tử có giá trị x xuất hiện đầu tiên trong mảng một chiều. (Nếu tìm thấy trả về vị trí xuất hiện x, ngược lại trả về -1)\nint TimX(int a[], int n, int x) \n{ \n    for(int i = 0; i &lt; n; i ++) \n        if(x==a[i]) \n            return i; \n    return -1; \n} \n\n\nViết hàm tìm vị trí phần tử có giá trị x xuất hiện cuối cùng trong mảng.\nViết hàm tìm vị trí của phần tử nhỏ nhất trong mảng các số nguyên.\nViết hàm tìm vị trí của phần tử lớn nhất trong mảng các số nguyên.\nViết hàm in vị trí các phần tử nguyên tố trong mảng các số nguyên.\nViết hàm in vị trí các phần tử nguyên tố lớn hơn 23.\nViết hàm tìm vị trí phần tử âm đầu tiên trong mảng. Nếu không có phần tử âm trả về -1.\nViết hàm tìm vị trí phần tử âm lớn nhất trong mảng.\nViết hàm tìm vị trí phần tử dương đầu tiên trong mảng. Nếu không có phần tử âm trả về -1.\nViết hàm tìm vị trí phần tử dương bé nhất trong mảng.\nViết hàm in các phần tử là bội của 3 và 5.\nViết hàm tìm số chẵn cuối cùng có trong mảng, nếu không tồn tại số chẵn hàm trả về -1.\nViết hàm tìm số lẻ lớn nhất có trong mảng, n ếu không tồn tại số lẻ hàm trả về -1.\nViết hàm tìm và đổi chỗ phần tử lớn nhất với phần tử nhỏ nhất trong mảng.\nNhập vào x. Viết hàm in ra màn hình những phần tử có giá trị từ 1 đến x có trong mảng.\nViết chương trình nhập vào một dãy số a gồm n số thực và dãy số b gồm m số thực (m,n\\leq100).\n\nIn ra những phần tử chỉ xuất hiện trong dãy a mà không xuất hiện trong dãy b.\nIn ra những phần tử xuất hiện ở cả hai dãy.\n\n\n\n\nKỹ thuật đếm phần tử - tần suất\n\nViết hàm đếm các phần tử chia hết cho 5 trong mảng các số nguyên.\nint Dem(int a[], int n) \n{ \n    int dem = 0; \n    for(int i = 0; i &lt; n; i++) \n        if(a[i] % 5 == 0) \n            dem++; \n    return dem; \n} \n\n\nViết hàm đếm các phần tử âm, dương trong mảng.\nViết hàm đếm các phần tử chẵn, lẻ trong mảng.\nViết hàm đếm số lần xuất hiện của phần tử x trong mảng.\nViết hàm đếm các phần tử nhỏ hơn x trong mảng.\nViết hàm đếm các phần tử là số nguyên tố trong mảng.\nViết hàm đếm các phần tử là số hoàn thiện trong mảng.\nViết hàm đếm các phần tử là bội của 3 và 5 trong mảng các số nguyên.\n\n\n\nKỹ thuật tính tổng - trung bình\n\nViết hàm tính tổng các phần tử trong mảng.\nint TinhTong(int a[], int n) \n{ \n    int tong = 0; \n    for(int i = 0; i &lt; n; i++) \n        tong = tong + a[i]; \n    return tong; \n} \n\n\nViết hàm tính giá trị trung bình các phần tử có giá trị âm trong mảng. Đối với hàm tính trung bình có điều kiện phải lưu ý khi chia giá trị (có thể mảng không có phần tử nào thoả điều kiện, nếu ta chia tức là chia cho 0).\nfloat TinhTrungBinhAm(int a[], int n) \n{ \n    int tong = 0; \n    int spt=0; \n    for(int i = 0; i &lt; n; i++) \n        if(a[i]&lt;0) \n        { \n            tong = tong + a[i]; \n            spt++; \n        } \n    if(spt==0) return 0; \n    return 1.0*tong/spt;\n}\n\n\nViết hàm tính tổng các phần tử chẵn trong mảng.\nViết hàm tính tổng các phần tử lẻ trong mảng các số nguyên.\nViết hàm tính tổng các phần tử nguyên tố trong mảng.\nViết hàm tính tổng các phần tử nằm ở vị trí chẵn trong mảng các số nguyên.\nViết hàm tính tổng các phần tử nằm ở vị trí nguyên tố trong mảng.\nViết hàm tính tổng các phần tử chia hết cho 5 có trong mảng.\nViết hàm tính tổng các phần tử cực đại trong mảng các số nguyên (phần tử cực đại là phần tử lớn hơn các phần tử xung quanh nó). Ví dụ: 1 5 2 6 3 5 1 8 6\nViết hàm tính tổng các phần tử cực tiểu trong mảng các số nguyên (phần tử cực tiểu là phần tử nhỏ hơn các phần tử xung quanh nó). Ví dụ: 6 4 2 9 5 3 7 1 5 8\nViết hàm tính tổng các phần tử là bội của 3 và 5 trong mảng các số nguyên.\nViết hàm tính tổng các phần tử là số hoàn thiện trong mảng các số nguyên.\nViết hàm tính giá trị trung bình của các số hoàn thiện trong mảng các số nguyên.\n\n\n\nKỹ thuật sắp xếp\n\nViết hàm sắp xếp mảng theo thứ tự tăng dần.\nvoid HoanVi(int &a, int &b) \n{ \n    int tam = a; \n    a = b; \n    b = tam; \n}\nvoid SapTang(int a[], int n) \n{ \n    for(int i = 0; i &lt; n-1; i++) \n        for(int j = i+1; j &lt; n; j++) \n            if(a[i] &gt; a [j]) \n                HoanVi(a[i], a[j]); \n} \n\n\nViết hàm sắp xếp mảng theo thứ tự giảm dần.\nViết hàm sắp xếp mảng theo thứ tự tăng dần của các phần tử là số nguyên tố.\nViết hàm sắp xếp các phần tử lẻ tăng dần.\nViết hàm sắp xếp các phần tử chẵn giảm dần.\nViết hàm sắp xếp các phần tử chẵn nằm bên trái theo thứ tự tăng dần còn các phần tử lẻ bên phải theo thứ tự giảm dần.\nViết hàm sắp xếp các phần tử âm giảm dần từ trái sang phải, phần tử dương tăng dần từ phải sang trái.\n\n\n\nKỹ thuật xoá phần tử\nDuyệt mảng từ trái sang phải. Xuất phát từ vị trí cần xoá tiến hành dời lần lượt các phần tử về phía trước cho đến khi kết thúc mảng, sau đó giảm kích thước mảng. Vấn đề đặt ra là tìm vị trí cần xóa theo điều kiện bài toán rồi thực hiện xóa.\n\nViết hàm xoá phần tử đầu tiên của mảng.\nvoid XoaDau(int a[], int &n) \n{ \n    for(int i = 0; i &lt; n-1; i++) \n        a[i] = a[i+1]; \n    n--; \n} \n\n\nViết hàm xoá phần tử tại vị trí vitri cho trước trong mảng.\nvoid XoaTaiViTri(int a[], int &n, int vitri) \n{ \n    for(int i = vitri; i &lt; n-1; i++) \n        a[i] = a[i+1]; \n    n--; \n} \n\n\nViết hàm xoá phần tử tại vị trí lẻ trong mảng.\nViết hàm xoá phần tử có giá trị lớn nhất trong mảng.\nNhập vào giá trị x. Viết hàm xoá tất cả các phần tử có giá trị nhỏ hơn x.\nNhập vào giá trị x. Viết hàm xoá phần tử có giá trị gần x nhất.\n\n\n\nKỹ thuật thêm/chèn phần tử\nDuyệt mảng từ phải sang trái. Xuất phát từ cuối mảng tiến hành đẩy lần lượt các phần tử về phía sau cho đến vị trí cần chèn, chèn phần tử cần chèn vào vị trí chèn và tăng kích thước mảng. Trước khi chèn ta phải xác định vị trí cần chèn theo điều kiện bài toán.\n\nThêm phần tử có giá trị x vào cuối mảng.\nvoid ChenCuoi(int a[], int &n, int x) \n{ \n    a[n]=x; \n    n++; \n} \n\n\nChèn phần tử có giá trị x vào mảng tại vị trí (vitri) cho trước\nvoid ChenTaiViTri(int a[], int &n, int x, int vitri) \n{ \n    for(int i = n; i &gt;vitri; i--) \n        a[i] = a[i-1]; \n    a[vitri] = x; \n    n++; \n} \n\n\nViết hàm chèn phần tử có giá trị x vào vị trí đầu tiên của mảng.\nViết hàm chèn phần tử có giá trị x vào phía sau phần tử có giá trị lớn nhất trong mảng.\nViết hàm chèn phần tử có giá trị x vào trước phần tử có giá trị là số nguyên tố đầu tiên trong mảng.\nViết hàm chèn phần tử có giá trị x vào phía sau tất cả các phần tử có giá trị chẵn trong mảng.\n\n\n\nKỹ thuật tách và ghép mảng\n\nCho mảng a kích thước n (n chẵn). Tách mảng a thành 2 mảng b và c sao cho: b có một nửa số phần tử đầu của mảng a, một nửa số phần tử còn lại đưa vào mảng c.\nvoid TachMang(int a[], int n, int b[], int &m, int c[], int &l) \n{ \n    int k=n/2;\n    m=l=0; \n    for(int i=0; i&lt;k; i++) \n    { \n        b[m++]=a[i]; \n        c[l++]=a[k+i] \n    } \n} \n\n\nCho 2 mảng số nguyên a và b kích thước lần lượt là n và m. Viết chương trình nối mảng b vào cuối mảng a.\nvoid GhepMang(int a[], int &n, int b[], int m) \n{ \n    for(int i=0; i&lt;m; i++) \n        a[n+i]=b[i]; \n    n=n+m; \n} \n\n\nCho 2 mảng số nguyên a và b kích thước lần lượt là n và m. Viết chương trình nối xen kẻ (đan xen) lần lượt các phần tử mảng a và b vào mảng c.\nĐưa lần lượt từng phần tử của mảng a và mảng b vào mảng c, tăng chỉ số tương ứng. Nếu một trong hai mảng hết trước thì chép tất cả các phần tử còn lại của mảng chưa hết vào mảng c. Đặt i là chỉ số của mảng a; j: chỉ số của mảng b và k là chỉ số của mảng c.\nvoid GhepMang(int a[], int &n, int b[], int m, int c[], int &k) \n{ \n    int i=0, j=0; \n    k=0; \n    while(i&lt;n && j&lt;m) \n    { \n        c[k++]=a[i++]; \n        c[k++]=b[j++]; \n    } \n    while(i&lt;n) \n        c[k++]=a[i++]; \n    while(j&lt;m) \n        c[k++]=b[j++]; \n} \n\n\nViết chương trình tách 1 mảng các số nguyên thành 2 mảng a và b, sao cho mảng a chứa toàn số lẻ và mảng b chứa toàn số chẵn. Ví dụ: mảng ban đầu: 1 3 8 2 7 5 9 0 10 thì mảng a: 1 3 7 5 9 và mảng b: 8 2 10\nCho 2 mảng số nguyên a và b kích thước lần lượt là n và m. Viết chương trình nối 2 mảng trên thành mảng c theo nguyên tắc chẵn ở đầu mảng và lẻ ở cuối mảng. Ví dụ: mảng a: 3 2 7 5 9 và mảng b: 1 8 10 4 12 6 thì mảng c: 6 12 4 10 2 8 3 1 7 5 9\n\n\n\nBài tập luyện tập và nâng cao\n\nViết chương trình nhập vào mảng A gồm n phần tử, trong quá trình nhập kiểm tra các phần tử nhập vào không được trùng, nếu trùng thông báo và yêu cầu nhập lại.\nViết hàm tính tổng của từng dãy con giảm có trong mảng.\n(*) Cho mảng các số nguyên a gồm n phần tử (n\\leq30000) và số dương k\\leq n. Hãy chỉ ra số hạng lớn thứ k của mảng. Ví dụ: mảng a: 6 3 1 10 11 18 và k = 2 thì kết quả là 10\n(*) Cho 2 dãy A, B các số nguyên (kích thước dãy A nhỏ hơn dãy B). Hãy kiểm tra xem A có phải là con của B hay không?\nViết hàm liệt kê các bộ 4 số a,b,c,d trong mảng các số nguyên (có ít nhất 4 phần tử và đôi một khác nhau) sao cho a+b=c+d.\n(*) Viết chương trình tính trung bình cộng của các tổng các dãy tăng dần có trong mảng các số nguyên. Ví dụ: 1 2 3 4 2 3 4 5 6 4 5 6 thì trung bình = 15.\nViết chương trình tính tổng tất cả các phần tử xung quanh trên mảng các số nguyên (phần tử xung quanh là hai phần tử bên cạnh cộng lai bằng chính nó, ví dụ: 1 3 2 thì 1, 2 là hai phần tử xung quanh của 3). Ví dụ: 1 3 2 5 3 9 6 tổng 17\n(**) Viết chương trình nhập vào hai số lớn a,b nguyên (a,b có từ 20 chữ số trở lên). Tính tổng, hiệu, tích, thương của hai số trên.\nViết hàm tính tổng các phần tử là số Amstrong (số Amstrong là số có đặc điểm như sau: số có k chữ số, tổng của các luỹ thừa bậc k của các ký số bằng chính số đó. Ví dụ: 153 là số có các ký số 1^{3}+5^{3}+3^{3}=153 là một số Amstrong).\nViết hàm tìm và xóa tất cả các phần tử trùng với x trong mảng một chiều các số nguyên, nếu không tồn tại phần tử x trong mảng thì trả về -1.\nViết hàm xoá tất cả những phần tử trùng nhau trong dãy chỉ giữ lại một phần tử trong đó. Ví dụ: 1 6 2 3 2 4 2 6 5 thì kế tquả 1 6 2 3 4 5\n(**) Viết hàm xoá những phần tử sao cho mảng kết quả có thứ tự tăng dần và số lần xoá là ít nhất.\nCho dãy a gồm n số nguyên có thứ tự tăng dần. Nhập vào một phần tử nguyên x, viết hàm chèn x vào dãy sao cho dãy vẫn có thứ tự tăng dần (không sắp xếp).\nViết chương trình tìm số lẻ nhỏ nhất lớn hơn mọi số chẵn có trong mảng.\nViết hàm tìm giá trị chẵn nhỏ nhất nhỏ hơn mọi giá trị lẻ trong mảng các số nguyên.\nViết hàm tìm phần tử xuất hiện nhiều nhất trong mảng các số nguyên.\nViết chương trình đếm và liệt kê các mảng con tăng dần trong mảng một chiều các số nguyên. Ví dụ: 6 5 3 2 3 4 2 7 các dãy con tăng dần là 2 3 4 và 2 7\nViết chương trình tìm mảng con tăng dần có tổng lớn nhất trong mảng một chiều.\n(*) Viết chương trình nhập vào một dãy số a gồm n số nguyên (n\\leq100). Tìm và in ra dãy con tăng dài nhất. Ví dụ: Nhập dãy a: 1 2 3 6 4 7 8 3 4 5 6 7 8 9 4 5 thì dãy con tăng dài nhất: 3 4 5 6 7 8 9\n(**) Viết chương trình tách 1 mảng các số nguyên thành 2 mảng a và b, sao cho kết quả thu được là:\n\nMảng a chứa toàn số lẻ tăng dần.\nMảng b chứa toàn số chẵn giảm dần\nKhông dùng thuật toán sắp xếp\n\nHướng dẫn: Tìm vị trí chèn thích hợp khi trích phần tử từ mảng ban đầu. Ví dụ: mảng ban đầu: 9 3 8 2 7 5 1 0 10 thì Mảng a: 1 3 5 7 9 Mảng b: 10 8 2\n(**) Viết chương trình in ra tam giác Pascal (dùng mảng một chiều).\nViết chương trình nhập vào dãy số a gồm n số thực (n\\leq100) và dãy số b gồm m số thực (m\\leq100).\n\nHãy sắp xếp hai dãy theo thứ tự tăng dần.\n(*) Trộn 2 dãy trên thành dãy c sao cho dãy c vẫn có thứ tự tăng.\nXuất dãy a,b,c ra màn hình.\n\n(*) Cho mảng c có n phần tử (n&lt;200), các phần tử là các chữ số trong hệ đếm cơ số 16 (Hexa). Hãy tách mảng c ra các mảng con theo điều kiện sau: các mảng con được giới hạn bởi hai lần xuất hiện thứ hai của con số trong dãy. Ví dụ: 123A4518B23 có các dãy con là 123A451, 23A4518B2, 23A4518B23\n(**) Cho hai số nguyên dương A,B. Hãy xác định hai số C,D tạo thành từ hai số A,B sao cho C là số lớn nhất, D là số nhỏ nhất. Khi gạch đi một số chữ số trong C (D), thì các số còn lại giữ nguyên tạo thành A, các chữ số bỏ đi giữ nguyên tạo thành B. Ví dụ: A = 52568, B = 462384 thì C = 54625682384, D = 45256236884.\nViết chương trình nhập vào dãy số a gồm n số nguyên (n\\leq100).\n\nHãy đảo ngược dãy đó. Ví dụ: Nhập a: 3 4 5 2 0 4 1 thì dãy sau khi đảo: 1 4 0 2 5 4 3\n(*) Hãy kiểm tra xem dãy đã cho có thứ tự chưa (dãy được gọi là thứ tự khi là dãy tăng hoặc dãy giảm).\n\nCho mảng a có n phần tử hãy cho biết mảng này có đối xứng hay không.\n(**) Hãy viết chương trình phát sinh ngẫu nhiên mảng các số nguyên gồm 10000 phần tử, mỗi phần tử có giá trị từ 0 đến 32000 và xây dựng hàm thống kê số lần xuất hiện các phần tử trong mảng, sau đó cho biết phần tử nào xuất hiện nhiều lần nhất. Ví dụ: mảng: 5 6 11 4 4 5 4 thì 5 xuat hien 2 lan, 6 xuat hien 1 lan, 11 xuat hien 1 lan, 4 xuat hien 3 lan và 4 xuat hien nhieu lan nhat\nCho mảng a có n phần tử. Nhập vào số nguyên dương k, dịch phải xoay vòng mảng a k lần. Ví dụ: mảng a: 5 7 2 3 1 9 và k = 2 thì dịch phải xoay vòng mảng a: 1 9 5 7 2 3",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG MỘT CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-5.html#tóm-tắt",
    "href": "chapter-5.html#tóm-tắt",
    "title": "5  KIỂU DỮ LIỆU MẢNG MỘT CHIỀU",
    "section": "5.3 TÓM TẮT",
    "text": "5.3 TÓM TẮT\nDữ liệu kiểu mảng dùng cho việc biểu diễn những thông tin có cùng kiểu dữ liệu liên tiếp nhau. Khi cài đặt bài tập mảng một chiều nên xây dựng thành những hàm chuẩn để dùng lại cho các bài tập khác. Các thao tác trên mảng đều theo quy tắc nhất định, chúng ta có thể ứng dụng mảng trong việc biểu diễn số lớn, dùng bảng tra, khử đệ qui,.v.v",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG MỘT CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-6.html",
    "href": "chapter-6.html",
    "title": "6  KIỂU DỮ LIỆU CHUỖI KÝ TỰ",
    "section": "",
    "text": "6.1 LÝ THUYẾT\nChuỗi ký tự là trường hợp đặc biệt của mảng một chiều. Chương này mô tả một số hàm thư viện thao tác trên chuỗi và các kỹ thuật cài đặt xử lý trên chuỗi.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CHUỖI KÝ TỰ</span>"
    ]
  },
  {
    "objectID": "chapter-6.html#lý-thuyết",
    "href": "chapter-6.html#lý-thuyết",
    "title": "6  KIỂU DỮ LIỆU CHUỖI KÝ TỰ",
    "section": "",
    "text": "Chuỗi ký tự\n\nLà một dãy các phần tử, mỗi phần tử có kiểu ký tự char.\nĐược kết thúc bằng ký tự \\0. Do đó khi khai báo độ dài của chuỗi luôn luôn khai báo dư 1 phần tử để chứa ký tự \\0.\n\n\n\nKhai báo biến chuỗi\n\nchar ⟨Tên chuỗi⟩ [⟨Số ký tự tối đa của chuỗi + 1⟩];\n\n\nKhai báo 1 chuỗi ký tự chuoi có tối đa 24 ký tự\nchar chuoi[25];\n\n\n\nHàm nhập chuỗi\nscanf(...)\nchar *gets(char *s); \n\nNhận các ký tự nhập từ phím cho đến khi nhấn phím ENTER và đưa vào s\nvoid main() \n{ \n    char chuoi[80]; \n    printf(\"Nhap vao chuoi:\"); \n    gets(chuoi); \n    printf(\"Chuoi vua nhap la: %s\\n\", chuoi); \n}\n\n\n\nHàm xuất chuỗi\nprintf(...)\nint puts(const char *s);\n\nXuất chuỗi ra màn hình.\nvoid main() \n{ \n    char chuoi[] = \"Vi du xuat chuoi\\n\"; \n    puts(string); \n}\n\n\n\nCác hàm về chuỗi trong thư viện ”string.h”\n\n\n\n\n\n\n\nHàm\nChức năng\n\n\n\n\nint strlen(char s[]);\ntrả về chiều dài của chuỗi\n\n\nstrcpy(char dest[], char src[]);\nsao chép chuỗi src vào chuỗi dest\n\n\nstrncpy(char dest[], char src[], int n);\nchép n ký tự đầu tiên từ chuỗi src vào chuỗi dest\n\n\nstrcat(char s1[],char s2[]);\nnối chuỗi s2 vào sau chuỗi s1\n\n\nstrncat(char s1[],char s2[],int n);\nnối n ký tự đầu tiên của chuỗi s2 vào sau chuỗi s1\n\n\nint strcmp(char s1[],char s2[]);\nso sánh thứ tự chuỗi s1 và s2\n\n\nint strncmp(char s1[],char s2[], int n);\nso sánh n ký tự đầu tiên của s1 và s2\n\n\nint strcmpi(char s1[],char s2[], int n);\nso sánh không phân biệt chữ hoa và chữ thường\n\n\nchar *strchr(char s[], char c);\ntìm xuất hiện đầu tiên của c trong s\n\n\nchar *strstr(char s1[], char s2[]);\ntìm xuất hiện đầu tiên của s2 trong s1\n\n\nchar *strtok(char s1[], char s2[]);\ntách s1 thành các token dựa vào s2\n\n\n\n\nNhập vào một chuỗi ký tự, xuất ra màn hình chuỗi bị đảo ngược thứ tự các ký tự. Ví dụ, nhập vào: Le Hoang thai và xuất ra màn hình: iahT gnaoH eL\n#include&lt;stdio.h&gt; \n#include&lt;conio.h&gt;\n#include&lt;string.h&gt; \nvoid DaoChuoi(char *s1, char *s2) \n{ \n    int l=strlen(s1); \n    for(int i=0; i&lt;l; i++) \n        s2[i]=s1[l-i-1];\n    s2[i]='\\0'; \n}\nvoid main() \n{\n    char s1[100], s2[100]; \n    printf(\"Nhap vao chuoi ky tu: \"); \n    gets(s1); \n    DaoChuoi(s1, s2); \n    printf(\"Ket qua sau khi dao nguoc chuoi: %s\", s2); \n}",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CHUỖI KÝ TỰ</span>"
    ]
  },
  {
    "objectID": "chapter-6.html#bài-tập",
    "href": "chapter-6.html#bài-tập",
    "title": "6  KIỂU DỮ LIỆU CHUỖI KÝ TỰ",
    "section": "6.2 BÀI TẬP",
    "text": "6.2 BÀI TẬP\n\nBài tập cơ bản\n\nCho biết kết quả của đoạn chương trình sau:\nchar s[20]=\"Truong DHKHTN TPHCM\", *p;\np = strtok(s, \" \"); \nwhile(p != NULL)\n{   \n    printf(\"%s\\n\",p); \n    p = strtok(NULL, \" \"); \n}\nCho biết kết quả của đoạn chương trình sau:\nchar s1[30]=\"Truong DHKHTN\", s1[30]=\"Tp. HCM\", s3[30], s[30]; \nstrcpy(s, s1); \nstrcpy(s3,\"aeiou\"); \nstrcat(s, s2); \nint n=strlen(s), k=0; \nprintf(\"Chuoi: %s\",s); \nfor(int i=0; i&lt;n; i++) \n{ \n    if(strchr(s3, s[i])) \n        k++; \n} \nprintf(\"\\nKet qua: %d\", k); \nViết chương trình nhập vào một chuỗi ký tự, đếm số ký tự có trong chuỗi.\nViết chương trình đếm có bao nhiêu khoảng trắng trong chuỗi.\nViết chương trình nhập vào một chuỗi, hãy loại bỏ những khoảng trắng thừa trong chuỗi.\nViết chương trình nhập vào hai chuỗi s_{1} và s_{2}, nối chuỗi s_{2} vào s_{1}. Xuất chuỗi s_{1} ra màn hình.\nĐổi tất cả các ký tự có trong chuỗi thành chữ thường (không dùng hàm strlwr).\nĐổi tất cả các ký tự trong chuỗi sang chữ in hoa (không dùng hàm struppr).\nViết chương trình đổi những ký tự đầu tiên của mỗi từ thành chữ in hoa.\nViết chương trình đổi chữ xen kẻ 1 chữ hoa và 1 chữ thường. Ví dụ: nhập ABCDEfgh đổi thành AbCdEfGh\nViết chương trình đảo ngược các ký tự trong chuỗi. Ví dụ: nhập ABCDE, xuất ra màn hình là EDCBA\nViết chương trình tìm kiếm 1 ký tự xem có trong chuỗi hay không, nếu có xuất ra vị trí của từ đó.\nViết 1 chương trình đếm một ký tự xuất hiện bao nhiêu lần trong chuỗi.\nViết chương trình tìm kiếm tên trong chuỗi họ tên. Nếu có thì xuất ra là tên này đã nhập đúng, ngược lại thông báo là đã nhập sai.\nViết chương đảo vị trí của từ đầu và từ cuối. Ví dụ: nhập bo an co xuat ra co an bo\nViết hàm cắt chuỗi họ tên thành chuỗi họ lót và chuỗi tên. Ví dụ: chuỗi họ tên là: Le Hoang Thai cắt ra 2 chuỗi là chuỗi họ lót Le Hoang và chuỗi tên là Thai\nNhập một chuỗi bất kỳ, sau đó hỏi người dùng cần tách bắt đầu từ đâu trong chuỗi trở về sau. Ví dụ: Nhập chuỗi TRUONG DAI HOC KHOA HOC TU NHIEN. Người nhập muốn tách bắt đầu từ chữ KHOA thì sẽ xuất ra chuỗi KHOA HOC TU NHIEN ra màn hình.\nViết hàm kiểm tra xem chuỗi có đối xứng hay không?.\nViết hàm tra xem trong chuỗi có ký tự số hay không nếu có tách ra thành một mảng số riêng.\nNhập một chuỗi bất kì, yêu cầu nhập 1 ký tự muốn xóa. Thực hiện xóa tất cả những ký tự đó trong chuỗi.\nViết chương trình tìm kiếm xem ký tự nào xuất nhiện nhiều nhất trong chuỗi.\nViết 1 chương trình xoá một từ nào đó trong chuỗi. Ví dụ: Chuỗi ban đầu KHOA CONG NGHE THONG TIN và từ THONG, và kết quả xuất ra: KHOA CONG NGHE TIN\n\n\n\nBài tập luyện tập và nâng cao\n\nĐổi các từ ở đầu câu sang chữ hoa và những từ không phải đầu câu sang chữ thường. Ví dụ: nGuYen vAN a đổi thành: Nguyen Van A\n(*) Viết chương trình đảo ngược thứ tự các từ có trong chuỗi Ví dụ: Nhập Truong DHKHTN TpHCM Xuất ra màn hình là: TpHCM DHKHTN Truong\nNhập 1 chuỗi bất kì, liệt kê xem mỗi ký tự xuất hiện mấy lần.\nViết hàm kiểm tra xem trong 2 chuỗi có bao nhiêu ký tự giống nhau.\nViết chương trìn mình chạy từ trái qua phải màn hình.\nViết 1 chương trình chèn 1 từ ở bất cứ vị trí nào mà người dùng yêu cầu.\n(*) Viết chương trình nhập vào một chuỗi đếm xem chuỗi có bao nhiêu từ. Các từ cách nhau bằng khoảng trắng, dấu chấm câu: dấu chấm (.), dấu phẩy (,), dấu chấm phẩy (;), dấu hỏi (?) và dấu chấm than (!).\n(**) Viết chương trình hiển thị một chuỗi ký tự. Chương trình cho phép di chuyển dấ u nháy sang trái, sang phải, lên dòng hay xuống dòng bằng phím mũi tên, chèn hay xoá ký tự tại vị trí dấu nháy.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CHUỖI KÝ TỰ</span>"
    ]
  },
  {
    "objectID": "chapter-6.html#tóm-tắt",
    "href": "chapter-6.html#tóm-tắt",
    "title": "6  KIỂU DỮ LIỆU CHUỖI KÝ TỰ",
    "section": "6.3 TÓM TẮT",
    "text": "6.3 TÓM TẮT\nCũng giống như kiểu mảng một chiều, thao tác truy xuất các phần tử trên chuỗi hoàn toàn tương tự. Bên cạnh đó, kiểu dữ liệu này còn được cài đặt sẵn một số hàm thư viện rất hữu ích nên trong quá trình thao tác trên chuỗi nên khi cài đặt ta cố gắng tận dụng tối đa những hàm liên quan. Không nên sử dụng hàm scanf để nhập chuỗi trong trường hợp chuỗi dữ liệu nhập vào có chứa khoảng trắng. Nếu nhập chuỗi phía sau hàm scanf nên chèn hàm fflush hoặc hàm flushall giữa scanf và gets để xóa vùng đệm, tránh trường hợp chương trình bỏ qua hàm gets do trong vùng đệm còn lưu ký tự xuống dòng của phím ENTER. Khi thao tác trên chuỗi lưu ý phải đảm bảo chuỗi được kết thúc bằng ký tự kết thúc '\\0'.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CHUỖI KÝ TỰ</span>"
    ]
  },
  {
    "objectID": "chapter-7.html",
    "href": "chapter-7.html",
    "title": "7  KIỂU DỮ LIỆU MẢNG HAI CHIỀU",
    "section": "",
    "text": "7.1 LÝ THUYẾT\nĐây là kiểu dữ liệu dùng để biểu diễn dữ liệu kiểu bảng, kiểu dữ liệu này rất thích hợp cho các bài toán liên quan đến ma trận, đồ thị hoặc ảnh và video số",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG HAI CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-7.html#lý-thuyết",
    "href": "chapter-7.html#lý-thuyết",
    "title": "7  KIỂU DỮ LIỆU MẢNG HAI CHIỀU",
    "section": "",
    "text": "Mảng hai chiều là tập hợp các phần tử được tổ chức theo dòng và cột\n\n\nKhai báo biến mảng\n\n⟨Kiểu dữ liệu phần tử⟩ ⟨Tên mảng⟩[⟨Số dòng⟩][⟨Số cột⟩]; \n\n\nKhai báo mảng hai chiều A và b\nint A[20][10];\nfloat b[10][10]; \n\n\n\nTruy xuất phần tử của mảng\n\n⟨tên mảng⟩[⟨chỉ số dòng⟩][⟨chỉ số cột⟩]\n\n\n\nKhai báo kiểu mảng\n\ntypedef ⟨Kiểu dữ liệu phần tử⟩ ⟨Tên kiểu mảng⟩[⟨Số dòng⟩][⟨Số cột⟩];\n\n\nKhai báo kiểu mảng hai chiều MANG2D chứa các số nguyên int có tối đa 100 dòng và 100 cột\n#define MAX 100\ntypedef int MANG2D[100][100];",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG HAI CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-7.html#bài-tập",
    "href": "chapter-7.html#bài-tập",
    "title": "7  KIỂU DỮ LIỆU MẢNG HAI CHIỀU",
    "section": "7.2 BÀI TẬP",
    "text": "7.2 BÀI TẬP\n\nBài tập cơ bản\n\n\nKỹ thuật nhập/xuất mảng hai chiều\n\nNhập và xuất mảng hai chiều\nvoid Nhap(MANG2D a, int &d, int &c) \n{ \n    printf(\"\\nNhap so dong: \"); \n    scanf(\" %d\", &d); \n    printf(\"\\nNhap so cot: \"); \n    scanf(\"%d\", &c); \n    for(int i = 0; i &lt; d; i ++) \n        for(int j = 0; j &lt; c; j ++) \n        { \n            printf(\" a[%d][%d] = \", i, j); \n            scanf(\"%d\", &a[i][j]); \n        } \n}\nvoid Xuat(MANG2D a, int d, int c) \n{ \n    printf(\"\\nNoi dung ma tran:\\n\"); \n    for(int i = 0; i &lt; d; i++) \n    { \n        for(int j = 0; j &lt; c; j++)  \n            printf(\" \\t %d \", a[i][j]); \n        printf(\"\\n\"); \n    } \n} \n\n\nViết hàm nhập ma trận các số nguyên dương (nhập sai báo lỗi và không cho nhập).\nViết hàm nhập/xuất ma trận các số thực.\nViết hàm in ra những phần tử có ký số tận cùng là 5.\nViết chương trình khởi tạo giá trị các phần tử là ngẫu nhiên cho ma trận các số nguyên kích thước m\\times n.\nViết hàm tạo ma trận a các số nguyên gồm 9 dòng 14 cột. Trong đó phần tử a[i][j]=i*j\nViết hàm in tam giác Pascal với chiều cao h. Ví dụ: h = 5\n1 \n1 1 \n1 2 1 \n1 3 3 1 \n1 4 6 4 1 \n\n\n\nKỹ thuật đặt cờ hiệu\n\nViết hàm kiểm tra xem trong ma trận các số nguyên có tồn tại các số nguyên lẻ lớn hơn 100 không?\nint KiemTraLe(MANG2D a, int d, int c) \n{ \n    int flag = 0; // tra ve 1 neu co nguoc lai tra ve 0\n    for(int i = 0; i &lt; d; i ++) \n        for(int j = 0; j &lt; c; j++) \n            if(a[i][j] % 2 != 0 && a[i][j] &gt; 100) \n            { \n                flag = 1; \n                break; \n            } \n    return flag; \n} \n\n\n\nKỹ thuật đặt lính canh\n\nViết hàm tìm phần tử nhỏ nhất trong ma trận.\nint TimMin(MANG2D a, int d, int c) \n{ \n    int min = a[0][0]; \n    for(int i = 0; i &lt; d; i ++)\n        for(int j = 0; j &lt; c; j ++) \n            if(a[i][j] &lt; min) \n                min = a[i][j]; \n    return min; \n} \n\n\n\nKỹ thuật tính tổng\n\nViết hàm tính tổng các phần tử trong ma trận.\nint TinhTong(MANG2D a, int d, int c) \n{ \n    int tong = 0;\n    for(int i = 0; i &lt; d; i ++) \n        for(int j = 0; j &lt; c; j ++) \n            tong + = a[i][j]; \n    return tong; \n} \n\n\nViết hàm tính tổng các phần tử trên cùng một dòng.\nViết hàm tính tổng các phần tử trên cùng một cột.\nViết hàm tính tổng các phần tử chẵn có trong ma trận.\nViết hàm tính tổng các phần tử là số nguyên tố có trong ma trận.\nViết hàm tính tổng các số hoàn thiện trong ma trận các số nguyên.\nViết hàm tính tổng các giá trị lớn nhất trên mỗi dòng.\nViết hàm tính giá trị trung bình của các phần tử nhỏ nhất trên mỗi cột.\n\n\n\nKỹ thuật tìm kiếm\n\nViết hàm tìm vị trí phần tử lớn nhất trong ma trận các số nguyên.\nViết hàm tìm vị trí phần tử nhỏ nhất trong ma trận các số nguyên.\nViết hàm tìm vị trí phần tử chẵn cuối cùng trong ma trận các số nguyên.\nViết hàm tìm phần tử âm lẻ lớn nhất trong ma trận.\nViết hàm tìm phần tử chẵn dương và nhỏ nhất trong ma trận.\nViết hàm tìm số hoàn thiện đầu tiên trong ma trận các số nguyên.\nViết hàm tìm số hoàn thiện lớn nhất trong ma trận các số nguyên.\nViết hàm tìm vị trí phần tử nguyên tố cuối cùng trong ma trận các số nguyên.\nViết hàm tìm trong 2 ma trận các số nguyên, những phần tử giống nhau.\nViết hàm tìm và liệt kê những phần tử cực đại trong ma trận (một phần tử được coi là cực đại khi nó lớn hơn các phần tử xung quanh nó).\nViết hàm tìm dòng có tổng lớn nhất trong ma trận các số thực.\nViết hàm tìm cột có tổng nhỏ nhất trong ma trận các số nguyên.\n\n\n\nKỹ thuật đếm\n\nViết hàm đếm các phần tử chẵn trong ma trận.\nint DemChan(MANG2D a, int d, int c) \n{ \n    int dem = 0; \n    for(int i = 0; i &lt; d; i ++) \n        for(int j = 0; j &lt; c; j ++) \n            if(a[i][j] % 2 == 0) \n                dem ++; \n    return dem; \n} \n\n\nViết hàm đếm các giá trị âm, dương trong ma trận các số thực.\nViết hàm đếm các giá trị chẵn, lẻ trong ma trận các số nguyên.\nViết hàm đếm số lần xuất hiện của phần tử x trong ma trận các số thực.\nViết hàm đếm các giá trị nhỏ hơn x trong ma trận các số thực.\nViết hàm đếm các phần tử nguyên tố trong ma trận các số nguyên.\nViết hàm đếm các giá trị cực đại trong ma trận các số nguyên.\nViết hàm đếm các giá trị cực tiểu trong ma trận các số nguyên.\nViết hàm đếm các cực trị trong ma trận các số nguyên (một phần tử được coi là cực trị khi nó là giá trị cực đại hay cực tiểu).\nViết hàm đếm các giá trị là số hoàn thiện trong ma trận các số nguyên.\n\n\n\nKỹ thuật sắp xếp\n\nViết hàm sắp xếp ma trận tăng dần từ trên xuống dưới và từ trái sang phải không dùng mảng phụ.\nvoid SapTang(MANG2D a, int d, int c) \n{ \n    for(int i = 0; i &lt;= d*c-2; i ++) \n        for(int j = 0; j &lt;= d*c-1; j ++) \n            if(a[i/c][i%c] &lt; a[j/c][j%c]) \n            { \n                int tmp = a[i/c][i%c]; \n                a[i/c][i%c] = a[j/c][j%c]; \n                a[j/c][j%c] = tmp; \n            } \n} \n\n\nViết hàm sắp xếp ma trận theo thứ tự tăng dần từ trên xuống dưới và từ trái qua phải theo phương pháp dùng mảng phụ.\nHướng dẫn: Đổ ma trận sang mảng một chiều, sắp xếp trên mảng một chiều theo thứ tự tăng dần, sau đó chuyển ngược mảng một chiều thành ma trận kết quả.\nViết hàm sắp xếp ma trận theo thứ tự giảm dần từ trên xuống dưới và từ trái sang phải.\nViết hàm sắp xếp các dòng trên ma trận theo thứ tự tăng dần.\nViết hàm sắp xếp các cột trên ma trận theo thứ tự giàm dần.\nViết hàm sắp xếp ma trận theo đường zig zag ngang. Ví dụ:\n\\begin{array}{ccc}\n5 & 6 & 3\\\\\n1 & 8 & 7\\\\\n2 & 4 & 9\n\\end{array}\\to\\begin{array}{ccc}\n1 & 2 & 3\\\\\n6 & 5 & 4\\\\\n7 & 8 & 9\n\\end{array}\nViết hàm sắp xếp ma trận theo đường zig zag chéo. Ví du:\n\\begin{array}{cccc}\n1 & 2 & 6 & 7\\\\\n3 & 5 & 8 & 13\\\\\n4 & 9 & 12 & 14\\\\\n10 & 11 & 15 & 16\n\\end{array}\nViết hàm sắp xếp ma trận theo đường xoắn ốc từ ngoài vào trong theo chiều kim đồng hồ. Ví dụ:\n\\begin{array}{cccc}\n1 & 2 & 3 & 4\\\\\n12 & 13 & 14 & 5\\\\\n11 & 16 & 15 & 6\\\\\n10 & 9 & 8 & 7\n\\end{array}\n\n\n\nKỹ thuật thêm - xoá - thay thế\n\nViết hàm xoá một dòng i trên ma trận.\nViết hàm xoá một cột j trên ma trận.\nViết hàm xoá dòng có tổng lớn nhất trên ma trận.\nViết hàm hoán vị dòng có tổng lớn nhất với dòng có tổng nhỏ nhất.\nViết hàm tìm và thay thế các phần tử chẵn trong ma trận bằng ước số nhỏ nhất của nó.\nViết hàm thay thế những phần tử có giá trị x thành phần tử có giá trị y trong ma trận (x,y nhập từ bàn phím)\n\n\n\nMảng vuông và các kỹ thuật xử lý\n\nMảng vuông là mảng hai chiều có số dòng và số cột bằng nhau.\n\n\nCho một mảng vuông\n\nĐường chéo chính (loại 1): chỉ số dòng = chỉ số cột\nĐường chéo song song với đường chéo chính (loại 1): chỉ số dòng - chỉ số cột = hằng số\nĐường chéo phụ (loại 2): chỉ số dòng + chỉ số cột = số dòng (hoặc số cột)\nĐường chéo song song với đường chéo phụ (loại 2): chỉ số dòng + chỉ số cột = hằng số\n\n\n\nCho mảng vuông A, in ra các phần tử nằm trên đường chéo song song với đường chéo chính và xuất phát từ (io,jo)\nfor(i = io, j = jo; i &lt; n; i ++, j ++) \n    printf(\"%4d\",A[i][j]); \n\n\nCho mảng vuông A, in ra các phần tử nằm trên đường chéo song song với đường chéo phụ và xuất phát từ (io,jo)\nfor(i = io, j = jo; i &lt; n && j &gt; = 0; i ++, j --) \n    printf(\"%4d\",A[i]][j]); \n\n\nViết chương trình in ra các phần tử nằm trên 2 đường chéo chính và phụ.\nViết hàm in ra các phần tử nằm phía trên đường chéo phụ của ma trận vuông các số nguyên.\nViết hàm in ra các phần tử nằm phía dưới đường chéo phụ của ma trận vuông các số nguyên.\nViết hàm in ra các phần tử nằm phía trên đường chéo chính của ma trận vuông các số nguyên.\nViết hàm in ra các phần tử nằm phía dưới đường chéo chính của ma trận vuông các số nguyên.\nViết hàm tìm phần tử lớn nhất nằm trên đường chéo chính của ma trận vuông.\nViết hàm in các số nguyên tố nằm trên đường chéo phụ của ma trận vuông.\nViết hàm tìm phần tử nhỏ nhất trên mỗi đường chéo loại 2 của ma trận.\nViết hàm tính tổng các phần tử nằm trên đường chéo chính của ma trận vuông.\nViết hàm tìm đường chéo có tổng lớn nhất trong các đường chéo loại\n\n\n\nViết hàm tính tổng các giá trị nhỏ nhất nằm trên từng đường chéo loại 2.\nViết hàm đến các phần tử nguyên tố trên đường chéo chính của ma trận vuông các số nguyên.\nViết hàm đếm các giá trị chẵn trên đường chéo chính của ma trận vuông các số nguyên.\nViết hàm đếm các giá trị là bội của 3 và 5 trên đường chéo chính của ma trận các số nguyên.\nViết hàm đếm các giá trị nguyên tố trên 2 đường chéo (chính, phụ) của ma trận vuông các số nguyên.\nCho ma trận vuông, viết hàm sắp xếp tăng dần các phần tử nằm trên các đường chéo song song với đường chéo chính.\nViết chương trình nhập một ma trận vuông các số nguyên, và thực hiện những công việc sau:\n\nSắp xếp các phần tử nằm trên các đường chéo loại 1 tăng dần\nSắp xếp các phần tử nằm trên các đường chéo loại 2 giảm dần.\nSắp xếp với điều kiện: các phần tử trên đường chéo chính tăng, các phần tử trên các đường chéo song song với đường chéo chính giảm.\n\n\n\n\nBài tập luyện tập và nâng cao\n\nViết chương trình tính tổng, tích của hai ma trận các số nguyên.\nViết hàm kiểm tra xem ma trận vuông các số nguyên có đối xứng qua đường chéo chính hay không.\nViết hàm kiểm tra xem trong ma trận vuông cấp n có hàng nào trùng nhau hay không, nếu có thì chỉ rõ những hàng nào. (trùng giá trị và vị trí).\nViết chương trình nhập vào ma trận vuông kích thước n\\times n. Hãy viết hàm thực hiện những công việc sau:\n\nIn ra các phần tử trên 4 đường biên của ma trận.\nTính tổng các phần tử trên biên.\n\n(*) Viết chương trình xoay ma trận các số thực 90^{o} ngược chiều kim đồng hồ. Ví dụ:\n\\begin{array}{cccc}\n1 & 2 & 3 & 4\\\\\n5 & 6 & 7 & 8\\\\\n9 & 10 & 11 & 12\\\\\n13 & 14 & 15 & 16\n\\end{array}\\to\\begin{array}{cccc}\n4 & 8 & 12 & 16\\\\\n3 & 7 & 11 & 15\\\\\n2 & 6 & 10 & 14\\\\\n1 & 5 & 9 & 13\n\\end{array}\nViết chương trình dịch phải xoay vòng một cột trong ma trận các số thực.\nViết chương trình dịch xuống xoay vòng một dòng trong ma trận các số thực.\n(*) Cho ma trận A_{m\\times n} các số nguyên hãy phát sinh ma trận B sao cho B là ma trận lật ngược của ma trận A. Ví dụ:\n\\begin{array}{cccc}\n1 & 2 & 3 & 4\\\\\n5 & 6 & 7 & 8\\\\\n9 & 10 & 11 & 12\\\\\n13 & 14 & 15 & 16\n\\end{array}\\to\\begin{array}{cccc}\n4 & 3 & 2 & 1\\\\\n8 & 7 & 6 & 5\\\\\n12 & 11 & 10 & 9\\\\\n16 & 15 & 14 & 13\n\\end{array}\n(**) Cho ma trận A_{m\\times n} hãy phát sinh ma trận B sao cho phần tử B(i,j) là trung bình cộng của các phần tử trong hình vuông 3\\times3 tâm tại (i,j). Ví dụ\n\\begin{array}{cccc}\n1 & 5 & 2 & 6\\\\\n4 & 2 & 3 & 6\\\\\n8 & 7 & 9 & 1\\\\\n10 & 2 & 12 & 13\n\\end{array}\\to\\begin{array}{cccc}\n3 & 2 & 4 & 4\\\\\n4 & 4 & 4 & 4\\\\\n5 & 6 & 6 & 7\\\\\n6 & 8 & 7 & 8\n\\end{array}\n(**) Cho ma trận các số nguyên dương A_{m\\times n}. Hãy xây dựng ma trận B_{m\\times n}. Sao cho phần tử B(i,j) là số lớn nhất trong ô vuông 3\\times3 tâm tại (i,j) của A. Ví dụ:\n\\begin{array}{cccc}\n1 & 5 & 2 & 6\\\\\n4 & 2 & 3 & 6\\\\\n8 & 7 & 9 & 1\\\\\n10 & 2 & 12 & 13\n\\end{array}\\to\\begin{array}{cccc}\n5 & 5 & 6 & 6\\\\\n8 & 9 & 9 & 9\\\\\n10 & 12 & 13 & 13\\\\\n10 & 12 & 13 & 13\n\\end{array}\n(**) Cho ma trận A_{m\\times n}. Hãy xây dựng ma trận B_{m\\times n} với phần tử B(i,j) được xác định theo qui tắc sau: tại vị trí (i,j) trên mảng A kẻ hai tia vuông góc với nhau, tạo thành với trục hoành một góc 45^{o} từ trên xuống dưới; B(i,j) là tổng của tất cả các số của vùng mặt phẳng tạo bởi hai tia này và các cạnh của bảng. Ví dụ:\n\\begin{array}{ccc}\n1 & 3 & 2\\\\\n6 & 4 & 3\\\\\n2 & 5 & 7\n\\end{array}\\to\\begin{array}{ccc}\n25 & 30 & 23\\\\\n13 & 18 & 15\\\\\n2 & 5 & 7\n\\end{array}\n(**) Cho ma trận vuông A_{m\\times n}. Hãy xây dựng mảng B_{m\\times n} bằng cách: phần tử B(i,j) là số lớn nhất trong tam giác vuông vẽ từ A(i,j) tới đường chéo chính. Ví dụ:\n\\begin{array}{ccc}\n1 & 3 & 2\\\\\n6 & 4 & 3\\\\\n2 & 5 & 7\n\\end{array}\\to\\begin{array}{ccc}\n1 & 4 & 7\\\\\n6 & 4 & 7\\\\\n7 & 7 & 7\n\\end{array}\n(*) Viết chương trình hiển thị đồng hồ điện tử (gồm giờ phút), với giờ lấy từ hệ thống và đồng hồ được cập nhật theo phút.\nHướng dẫn: Tạo 1 ma trận giá trị gồm 0 hoặc 1, vị trí nào cần hiển thị thì gán giá trị là 1, ngược lại có giá trị là 0. Sau mỗi phút cập nhật lại ma trận và hiển thị lên màn hình. Ví dụ: 01 giờ 25 phút\n  1111   11    11111111 11111111\n11    11 11 11       11 11 \n11    11 11    11111111 11111111\n11    11 11 11 11             11 \n  1111   11    11111111 11111111\nNhập vào mảng hai chiều gồm n dòng và m cột các số nguyên. Hãy tìm phần tử lớn nhất trên mỗi dòng và đồng thời nhỏ nhất trên mỗi cột, hoặc lớn nhất trên mỗi cột và đồng thời nhỏ nhất trên mỗi dòng. Có bao nhiêu phần tử như thế? Ví dụ:\n\n\n\n3\n6\n2\n1\n\n\n4\n7\n6\n9\n\n\n5\n15\n8\n7\n\n\n\nViết chương trình tạo ngẫu nhiên một ma trận các số nguyên trong khoảng \\left[0,...,50\\right], tìm những phần tử cực đại (là phần tử lớn hơn các phần tử xung quanh). Ví dụ:\n\n\n\n2\n6\n8\n4\n\n\n9\n7\n5\n3\n\n\n6\n2\n8\n1\n\n\n\n(**) Cho ma trận các số nguyên A_{m\\times n} (m,n\\geq3). Hãy tìm ma trận con (3\\times3) có tổng lớn nhất. Ví dụ:\n\\begin{array}{cccc}\n1 & 2 & 3 & 4\\\\\n5 & 6 & 7 & 8\\\\\n9 & 10 & 11 & 11\\\\\n13 & 14 & 15 & 16\n\\end{array}\\to\\begin{array}{ccc}\n6 & 7 & 8\\\\\n10 & 11 & 11\\\\\n14 & 15 & 16\n\\end{array}\nNhập ma trận vuông cấp n\\times n (n&lt;10). In ra các phần tử của ma trận này theo hướng của đừơng chéo chính:\n(**) Hãy điền các số từ 1 đến n^{2} vào ma trận cấp n (n&gt;2), chỉ xét trường hợp n là số lẻ với tính chất P là tổng các số bằng nhau.\nHướng dẫn: Ma phương của một bảng vuông cấp n, trong mỗi ô nhận một giá trị sao cho, mỗi hàng, mỗi cột và mỗi đường chéo đều thoả mãn một tính chất P nào đó cho trước. Ví dụ:\n\\begin{array}{ccc}\n2 & 7 & 6\\\\\n9 & 5 & 1\\\\\n4 & 3 & 8\n\\end{array}\n(*) Viết hàm in ma trận các số nguyên dương theo qui luật được mô tả như sau: các phần tử phía trên đường chéo phụ là giá trị bình phương, các giá trị từ đường chéo phụ trở xuống là các số nguyên tố. Ví dụ:\n\\begin{array}{ccccc}\n1 & 9 & 36 & 100 & 31\\\\\n4 & 25 & 81 & 37 & 17\\\\\n16 & 64 & 41 & 19 & 7\\\\\n49 & 43 & 23 & 11 & 3\\\\\n47 & 29 & 13 & 5 & 2\n\\end{array}\nCho ma trận vuông a cấp n (n lẻ và 3\\leq n\\leq15), mỗi phần tử đều có giá trị nguyên dương. Hãy xây dựng hàm kiểm tra xem ma trận a có phải là ma phương hay không?\n(**) Viết chương trình giải bài toán 8 hậu. Hãy đặt 8 con hậu trên bàn cờ 8\\times8 sao cho chúng không ăn nhau (2 hậu ăn nhau khi cùng hàng, cùng cột và cùng nằm trên đường chéo).\nHướng dẫn: Dùng ma trận 8\\times8 để lưu bàn cờ. Mỗi ô có 3 trạng thái:\n\nCó hậu 1\nÔ trống 0\nÔ không dược đi -1\n\n(**) Viết chương trình giải bài toán mã đi tuần. Hãy đi con mã 64 lượt đi trên bàn cờ 8\\times8 sao cho mỗi ô chỉ đi qua một lần (xuất phát từ một ô bất kỳ)\nHướng dẫn: Đứng tại một ô trên bàn cờ con mã có thể đi được 1 trong 8 hướng sau. Khai báo 8 hướng đi của mã như sau:\ntypedef struct DIEM \n{ \n    int x, y; \n}; \nDIEM huongdi[8]={{-2,-1},{-2,1},{-1,2},{1,2},\n                {2,1},{2,-1},{1,-2},{-1,-2}};\nTrong đó mỗi thành phần của huongdi là độ lệch của dòng và cột so với vị trí của con mã. Ví dụ: huongdi[0] có độ lệch 2 dòng và 1 cột. (Giá trị âm biểu thị độ lệch về bên trái cột hay hướng lên của dòng). Chọn vị trí đi kế tiếp sao cho vị trí đó phải gần với biên hay góc nhất (tức số đường đi có thể đi là ít nhất).\nViết chương trình giải bài toán 8-puzzle. Cho ma trận vuông 3\\times3 gồm các số nguyên từ 0 đến 8 trong đó 0 là ô trống. Bài toán đặt ra là hãy đưa ma trận ở một trạng thái đầu về trạng thái đích, mỗi lần chỉ dịch chuyển được 1 ô. Ví dụ:\nTrạng thái đầu\n\n\n\n2\n1\n0\n\n\n3\n8\n7\n\n\n6\n4\n5\n\n\n\n\\toTrạng thái đích\n\n\n\n1\n2\n3\n\n\n4\n5\n6\n\n\n7\n8\n0",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG HAI CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-7.html#tóm-tắt",
    "href": "chapter-7.html#tóm-tắt",
    "title": "7  KIỂU DỮ LIỆU MẢNG HAI CHIỀU",
    "section": "7.3 TÓM TẮT",
    "text": "7.3 TÓM TẮT\nKiểu dữ liệu mảng hai chiều được ứng dụng rộng rãi trong các bài toán về tìm đường đi trong đồ thị, xử lý ảnh, xử lý những dữ liệu dạng bảng.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>KIỂU DỮ LIỆU MẢNG HAI CHIỀU</span>"
    ]
  },
  {
    "objectID": "chapter-8.html",
    "href": "chapter-8.html",
    "title": "8  KIỂU DỮ LIỆU CẤU TRÚC",
    "section": "",
    "text": "8.1 LÝ THUYẾT\nCung cấp cơ chế cho phép khai báo các kiểu dữ liệu mới để giải quyết theo yêu cầu của bài toán dựa vào những kiểu dữ liệu cơ bản được cài đặt sẵn trong ngôn ngữ lập trình.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CẤU TRÚC</span>"
    ]
  },
  {
    "objectID": "chapter-8.html#lý-thuyết",
    "href": "chapter-8.html#lý-thuyết",
    "title": "8  KIỂU DỮ LIỆU CẤU TRÚC",
    "section": "",
    "text": "Kiểu dữ liệu cấu trúc (struct) là gom nhóm các phần tử có thể không cùng kiểu dữ liệu.\n\n\nKhái báo kiểu dữ liệu cấu trúc\n\nstruct ⟨Tên cấu trúc⟩ {\n    ⟨Các dữ liệu thành phần⟩\n}; \n\nNgoài ra, ta có thể dùng từ khoá typedef để định nghĩa một tên mới cho kiểu dữ liệu đã có.\n\ntypedef struct {\n    ⟨Các dữ liệu thành phần⟩\n} ⟨Tên kiểu dữ liệu cấu trúc⟩; \n\n\nKiểu dữ liệu về ngày DATE gồm các thành phần\n\nThứ (thu): chuỗi có tối đa 4 ký tự.\nNgày (ngay): số nguyên 1 byte.\nTháng (thang): số nguyên 1 byte.\nNăm (nam): số nguyên 2 bytes.\n\nTa định nghĩa cấu trúc SDATE\nstruct SDATE { \n    char thu[5]; \n    unsigned char ngay; \n    unsigned char thang; \n    int nam; \n}; \nhoặc kiểu dữ liệu cấu trúc DATE\ntypedef struct SDATE { \n    char thu[5]; \n    unsigned char ngay; \n    unsigned char thang; \n    int nam; \n} DATE; \n\n\n\nKhai báo biến cấu trúc\nKhi ta định nghĩa kiểu dữ liệu tức là ta có một kiểu dữ liệu mới, muốn sử dụng ta phải khai báo biến. Cú pháp khai báo kiểu dữ liệu cũng giống như cách khai báo của các kiểu dữ liệu chuẩn.\n\nstruct ⟨tên cấu trúc⟩ ⟨tên biến⟩;\nhoặc\n⟨tên kiểu dữ liệu cấu trúc⟩ ⟨tên biến⟩;\n\n\nKhai báo biến x có kiểu cấu trúc SDATE\nstruct SDATE x;\nKhai báo biến x có kiểu DATE\nDATE x;\n\nLưu ý kiểu các thành phần của một cấu trúc cũng có thể là kiểu dữ cấu trúc.\n\nĐịnh nghĩa kiểu dữ liệu của học sinh HOCSINH gồm:\n\nMã số học sinh (MSHS): chuỗi có tối đa 5 ký tự.\nHọ tên (hoten): chuỗi có tối đa 30 ký tự.\nNgày tháng năm sinh (ngaysinh): kiểu DATE.\nĐịa chỉ (diachi): chuỗi có tối đa 50 ký tự.\nGiới tính (phai): chuỗi có tối đa 3 ký tự.\nĐiểm trung bình (diemtb): số thực.\n\nTa định nghĩa kiểu HOCSINH như sau:\ntypedef struct HOCSINH { \n    char MSHS[6]; \n    char hoten[31]; \n    DATE ngaysinh; \n    char diachi[51]; \n    unsigned char phai[4]; \n    float diemtb; \n}; \n\n\n\nTruy xuất thành phần\n\n⟨Tên biến cấu trúc⟩.⟨Tên thành phần⟩ \n\n\nTruy xuất thành phần ngay của biến x\nDATE x; // khai báo biến x kieu DATE \nx.ngay = 5; // gán ngay bằng 5 \n\n\nViết chương trình nhập vào toạ độ hai điểm trong mặt phẳng và tính tổng hai toạ độ này.\n#include &lt;conio.h&gt; \n#include &lt;stdio.h&gt;\n//khai báo một kiểu dữ liệu DIEM gồm tọa độ x và y \ntypedef struct { \n    int x; \n    int y; \n} DIEM; \nvoid Nhap (DIEM &d) \n{ \n    printf(\"\\nNhap vao tao do diem\\n\"); \n    printf(\"Hoanh do: \"); \n    scanf(\"%d\", &d.x); \n    printf(\"Tung do: \"); \n    scanf(\"%d\", &d.y); \n}\nvoid Xuat(DIEM d) \n{ \n    printf(\"\\nToa do diem: (%d, %d)\",d.x,d.y); \n}\nDIEM Tong(DIEM d1,DIEM d2) \n{ \n    DIEM temp; \n    temp.x = d1.x + d2.x; \n    temp.y = d1.y + d2.y; \n    return Temp; \n}\nvoid main() \n{ \n    DIEM A, B, AB; // khai bao 3 diem A, B, AB; \n    Nhap (A); \n    Xuat (A); \n    Nhap (B); \n    Xuat (B); \n    printf(\"\\n Tong cua hai diem vua nhap la: \"); \n    AB = Tong(A, B); \n    Xuat(AB); \n    getch(); \n} \n\n\n\nMảng cấu trúc\n\nCách khai báo tương tự như mảng một chiều hay ma trận (Kiểu dữ liệu bây giờ là kiểu dữ liệu có cấu trúc).\nCách truy cập phần tử trong mảng cũng như truy cập trên mảng một chiều hay ma trận. Nhưng do từng phần tử có kiểu cấu trúc nên phải chỉ định rõ cần lấy thành phần nào, tức là phải truy cập đến thành phần cuối cùng có kiểu là dữ liệu cơ bản (xem lại bảng các kiểu dữ liệu cơ bản).\n\n\n\nKỹ thuật viết chương trình có mảng cấu trúc\nDo kiểu dữ liệu có cấu trúc thường chứa rất nhiều thành phần nên khi viết chương trình loại này ta cần lưu ý:\n\nXây dựng hàm xử lý cho một kiểu cấu trúc.\nMuốn xử lý cho mảng cấu trúc, ta gọi lại hàm xử lý cho một kiểu cấu trúc đã được xây dựng bằng cách dùng vòng lặp.\n\n\nCho một lớp học gồm n học sinh (n\\leq50). Thông tin của một học sinh được mô tả trong ví dụ trước. Hãy viết chương trình nhập và xuất danh sách học sinh sau đó đếm xem có bao nhiêu học sinh được lên lớp (Điều kiện được lên lớp là điểm trung bình \\geq5.0). Cách làm:\n\nTrước hết ta phải xây dựng hàm nhập và xuất cho 1 học sinh.\nXây dựng hàm nhập và xuất ngày tháng năm (Kiểu dữ liệu DATE).\nSau đó mới xây dựng hàm nhập và xuất cho danh sách học sinh.\n\n#define MAX 50 \ntypedef struct { \n    char thu[5]; \n    unsigned char ngay; \n    unsigned char thang; \n    int nam; \n} DATE; \ntypedef struct { \n    char MSHS[6]; \n    char hoten[31]; \n    struct DATE ngaysinh; \n    char diachi[51]; \n    unsigned char phai[4]; \n    float diemtb; \n} HOCSINH;\nvoid NhapNamSinh(DATE &d); \nvoid XuatNamSinh(DATE d); \nvoid Nhap1HS(HOCSINH &hs); \nvoid Xuat1HS(HOCSINH hs); \nvoid NhapDSHS(HOCSINH lh[], int &n); \nvoid XuatDSHS(HOCSINH lh[], int n); \nint DemHSLenLop(HOCSINH lh[], int n);\nvoid main() \n{ \n    HOCSINH lh[MAX]; // Khai báo mảng có tối đa 50 học sinh\n    int n, sohsdau; \n    NhapDSHS(lh, n); \n    XuatDSHS(lh, n); \n    sohsdau = DemHSLenLop(lh, n); \n    printf(\"\\nSo luong hoc sinh duoc len lop la: %d\", sohsdau); \n    getch(); \n}\nvoid NhapNamSinh(DATE &d) \n{ \n    printf(\"\\nNhap vao ngay: \"); \n    scanf(\"%u\", &d.ngay); \n    printf(\"\\nNhap vao thang: \"); \n    scanf(\"%u\", &d.thang); \n    printf(\"\\nNhap vao nam: \"); \n    scanf(\"%d\", &d.nam); \n}\nvoid XuatNamSinh(DATE d) \n{ \n    printf(\"%02u / %02u / %4d\", d.ngay, d.thang, d.nam); \n}\nvoid Nhap1HS(HOCSINH &hs) \n{ \n    flushall(); // Xoa vung dem \n    printf(\"\\nNhap ma so hoc sinh: \"); \n    gets(hs.MSHS); \n    printf(\"\\nNhap ho ten hoc sinh: \"); \n    gets(hs.hoten); \n    printf(\"\\nNhap ngay thang nam sinh: \");  \n    flushall(); // Xoa vung dem \n    NhapNamSinh(hs.ngaysinh);\n    printf(\"\\nNhap vao dia chi: \"); \n    flushall(); // Xoa vung dem\n    gets(hs.diachi); \n    printf(\"\\nPhai: \"); \n    gets(hs.phai); \n    printf(\"\\nNhap vao diem trung binh: \"); \n    flushall(); \n    scanf(\"%f\", &hs.diemtb);\n}\nvoid NhapDSHS(HOCSINH lh[], int &n)\n{ \n    printf(\"\\nNhap vao so luong hoc sinh: \"); \n    scanf(\"%d\", &n); \n    for(int i=0; i&lt;n; i++) \n    { \n        printf(\"\\nNhap vao thong tin cua hoc sinh thu %d:\\n\", i+1); \n        Nhap1HS(lh[i]); //Goi ham nhap thong tin 1 hoc sinh \n    } \n}\nvoid Xuat1HS(HOCSINH hs) \n{ \n    printf(\"\\nMa so hoc sinh: %s\", hs.MSHS); \n    printf(\"\\nHo ten hoc sinh: %s\", hs.hoten); \n    printf(\"\\nNgay thang nam sinh: \"); \n    XuatNamSinh(hs.ngaysinh); \n    printf(\"\\nDia chi: %s\", hs.diachi); \n    printf(\"\\nPhai: %s\", hs.phai); \n    printf(\"\\nDiem trung binh: %2.2f\", hs.diemtb); \n}\nvoid XuatDSHS(HOCSINH lh[], int n) \n{\n    for(int i=0; i&lt;n; i++) \n    {\n        printf(\"\\n\\nThong tin hoc sinh thu %d:\", i+1);\n        Xuat1HS(lh[i]); //Goi ham xuat thong tin 1 hoc sinh \n    } \n} \nint DemHSLenLop(HOCSINH lh[], int n)\n{ \n    int d=0; \n    for(int i=0; i&lt;n; i++) \n        if(lh[i].diemtb&gt;=5.0) \n            d++; \n    return d; \n} \nKết quả ví dụ khi chạy chương trình:\nNhap vao thong tin cua hoc sinh thu 1: \nNhap ma so hoc sinh: 02313 \nNhap ho ten hoc sinh: Nguyen Van A \nNhap ngay thang nam sinh: \nNhap vao ngay: 12 \nNhap vao thang: 03 \nNhap vao nam: 1980 \nNhap vao dia chi: 60 Phan Dang Luu Q.Phu Nhuan \nPhai: Nam Nhap vao diem trung binh: 6.5\n\nNhap vao thong tin cua hoc sinh thu 2: \nNhap ma so hoc sinh: 03852 \nNhap ho ten hoc sinh: Ly Thi B \nNhap ngay thang nam sinh: \nNhap vao ngay: 05 \nNhap vao thang: 12 \nNhap vao nam: 1981 \nNhap vao dia chi: 24 Ly Tu Trong Q.1 \nPhai: Nu Nhap vao diem trung binh: 3.5\n\nThong tin hoc sinh thu 1: \nMa so hoc sinh: 02313 \nHo ten hoc sinh: Nguyen Van A \nNgay thang nam sinh: 12 / 03 / 1980 \nDia chi: 60 Phan Dang Luu Q.Phu Nhuan \nPhai: Nam \nDiem trung binh: 6.50 \n\nThong tin hoc sinh thu 2: \nMa so hoc sinh: 03852 \nHo ten hoc sinh: Ly Thi B \nNgay thang nam sinh: 05 / 12 / 1981 \nDia chi: 24 Ly Tu Trong Q.1 \nPhai: Nu Diem trung binh: 3.50 \nSo luong hoc sinh duoc len lop la: 1 \n\n\nCho một mảng các phân số (PHANSO) gồm n phần tử (n\\leq50). Hãy viết chương trình nhập và xuất danh sách các phân số sau đó tìm phân số có giá trị lớn nhất, tổng và tích các phân số và nghịch đảo giá trị các phân số trong mảng. Cách làm:\n\nTrước hết ta phải xây dựng hàm nhập và xuất cho 1 phân số.\nXây dựng hàm tính tổng, hiệu, tích, thương, rút gọn, so sánh và nghịch đảo cho 2 phân số.\nSau đó mới xây dựng hàm nhập, xuất, tính tổng, tích cho mảng các phân số.\n\n#define MAX 100 \ntypedef struct { \n    int tu, mau; \n} PHANSO;\nvoid NhapPS(PHANSO &ps); \nvoid XuatPS(PHANSO ps); \nvoid NhapMangPS(PHANSO dsps[], int &n); \nvoid XuatMangPS(PHANSO dsps[], int n); \nPHANSO TimMax(PHANSO dsps[], int n); \nint KiemTra(PHANSO ps);\n//Tra ve 0: Neu khong hop le\n//Tra ve 1: Neu hop le \nint USCLN(int a, int b); PHANSO RutGon(PHANSO ps); \nPHANSO NghichDao(PHANSO ps); \nPHANSO Nhan(PHANSO ps1, PHANSO ps2); \nPHANSO Chia(PHANSO ps1, PHANSO ps2); \nPHANSO Tru(PHANSO ps1, PHANSO ps2); \nPHANSO Cong(PHANSO ps1, PHANSO ps2); \nint SoSanh(PHANSO ps1, PHANSO ps2); \n//Tra ve 0: ps1=ps2 \n//Tra ve 1: ps1&gt;ps2 \n//Tra ve -1: ps1&lt;ps2 \nPHANSO TongCacPS(PHANSO dsps[], int n); \nPHANSO TichCacPS(PHANSO dsps[], int n);\nvoid NghichDaoCacPS(PHANSO dsps[], int n); \nvoid main() \n{ \n    int n; \n    PHANSO a[MAX], max, s, p; \n    NhapMangPS(a, n); \n    printf(\"\\nMang cac phan so vua nhap: \"); \n    XuatMangPS(a, n); \n    max=TimMax(a, n); \n    printf(\"\\nPhan so co gia tri lon nhat: \"); \n    XuatPS(max);\n    s=TongCacPS(a, n); \n    printf(\"\\nTong gia tri cac phan so co trong mang: \"); \n    XuatPS(s);\n    p=TichCacPS(a, n); \n    printf(\"\\nTich gia tri cac phan so co trong mang: \");\n    XuatPS(p);\n    NghichDaoCacPS(a, n); \n    printf(\"\\nMang phan so sau khi nghich dao cac phan tu: \"); \n    XuatMangPS(a, n);\n    getch(); \n}\nvoid NhapPS(PHANSO &ps) \n{\n    do { \n        printf(\"\\nNhap tu so: \"); \n        scanf(\"%d\", &ps.tu); \n        printf(\"\\nNhap mau so: \"); \n        scanf(\"%d\", &ps.mau); \n        if(!KiemTra(ps)) \n            printf(\"\\nMau so khong duoc bang 0, nhap lai phan so\\n\");\n        else \n            break; \n    } while(1); \n    ps=RutGon(ps); \n}\nvoid XuatPS(PHANSO ps) \n{ \n    printf(\"%d\", ps.tu); \n    if(ps.tu&&ps.mau!=1) \n    printf(\"/%d\", ps.mau); \n} \nvoid NhapMangPS(PHANSO dsps[], int &n)\n{ \n    printf(\"\\nNhap so luong phan so: \"); \n    scanf(\"%d\", &n); \n    for(int i=0; i&lt;n; i++) \n    { \n        printf(\"\\nNhap vao phan so thu %d: \", i+1);\n        NhapPS(dsps[i]); \n    } \n}\nvoid XuatMangPS(PHANSO dsps[], int n)\n{\n    for(int i=0; i&lt;n; i++)\n    { \n        XuatPS(dsps[i]); \n        printf(\"\\t\"); \n    } \n}\nint KiemTra(PHANSO ps) \n{ \n    if(ps.mau==0) return 0; \n    return 1; \n}\nint USCLN(int a, int b) \n{ \n    a=abs(a); \n    b=abs(b); \n    while(a!=b) \n    { \n        if(a&gt;b) a=a-b; \n        else b=b-a; \n    } \n    return a; \n}\nPHANSO RutGon(PHANSO ps) \n{ \n    int us; \n    if(ps.tu==0) return ps;\n    us=USCLN(ps.tu, ps.mau); \n    ps.tu=ps.tu/us; \n    ps.mau=ps.mau/us; \n    return ps; \n}\nPHANSO NghichDao(PHANSO ps) \n{ \n    PHANSO kq; \n    kq.tu=ps.mau;\n    kq.mau=ps.tu; \n    return kq; \n} \nPHANSO Nhan(PHANSO ps1, PHANSO ps2) \n{ \n    PHANSO kq; \n    kq.tu=ps1.tu*ps2.tu;\n    kq.mau=ps1.mau*ps2.mau; \n    kq=RutGon(kq); \n    return kq; \n}\nPHANSO Chia(PHANSO ps1, PHANSO ps2)\n{ \n    PHANSO kq; \n    kq=Nhan(ps1, NghichDao(ps2)); \n    return kq; \n}\nPHANSO Tru(PHANSO ps1, PHANSO ps2)\n{\n    PHANSO kq;\n    kq.tu=ps1.tu*ps2.mau-ps1.mau*ps2.tu; \n    kq.mau=ps1.mau*ps2.mau; kq=RutGon(kq); \nr   return kq; \n}\nPHANSO Cong(PHANSO ps1, PHANSO ps2) \n{ \n    PHANSO kq; \n    kq.tu=ps1.tu*ps2.mau+ps1.mau*ps2.tu; \n    kq.mau=ps1.mau*ps2.mau;\n    kq=RutGon(kq); \n    return kq;\n}\nint SoSanh(PHANSO ps1, PHANSO ps2)\n{ \n    ps1=RutGon(ps1); \n    ps2=RutGon(ps2); \n    if(ps1.tu==ps2.tu&&ps1.mau==ps2.mau)\n        return 0; \n    if(ps1.tu*ps2.mau&gt;ps2.tu*ps1.mau) \n        return 1; \n    return -1;\n} \nPHANSO TimMax(PHANSO dsps[], int n)\n{ \n    PHANSO max; \n    max=dsps[0]; \n    for(int i=1; i&lt;n; i++) \n    if(SoSanh(dsps[i], max)==1) \n        max=dsps[i]; \n    return max; \n}\nPHANSO TongCacPS(PHANSO dsps[], int n) \n{ \n    PHANSO s=dsps[0]; \n    for(int i=1; i&lt;n; i++)\n    {\n        s=Cong(s, dsps[i]);\n    } \n    return s; \n}\nPHANSO TichCacPS(PHANSO dsps[], int n)\n{ \n    PHANSO p=dsps[0]; \n    for(int i=1; i&lt;n; i++) \n    {\n        p=Nhan(p, dsps[i]);\n    } \n    return p; \n}\nvoid NghichDaoCacPS(PHANSO dsps[], int n)\n{ \n    for(int i=0; i&lt;n; i++)\n    {\n        dsps[i]=NghichDao(dsps[i]); \n    } \n} \nKết quả ví dụ khi chạy chương trình:\nNhap so luong phan so: 5 \nNhap vao phan so thu 1: \nNhap tu so: 1 \nNhap mau so: 3\n\nNhap vao phan so thu 2: \nNhap tu so: 7 \nNhap mau so: 4\n\nNhap vao phan so thu 3: \nNhap tu so: 9 \nNhap mau so: 7\n\nNhap vao phan so thu 4: \nNhap tu so: 5 \nNhap mau so: 6\n\nNhap vao phan so thu 5: \nNhap tu so: 4 \nNhap mau so: 7\n\nMang cac phan so vua nhap: 1/3 7/4 9/7 5/6 4/7 \nPhan so co gia tri lon nhat: 7/4 \nTong gia tri cac phan so co trong mang: 401/84 \nTich gia tri cac phan so co trong mang: 5/14 \nMang phan so sau khi nghich dao cac phan tu: 3 4/7 7/9 6/5 7/4",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CẤU TRÚC</span>"
    ]
  },
  {
    "objectID": "chapter-8.html#bài-tập",
    "href": "chapter-8.html#bài-tập",
    "title": "8  KIỂU DỮ LIỆU CẤU TRÚC",
    "section": "8.2 BÀI TẬP",
    "text": "8.2 BÀI TẬP\n\nBài tập cơ bản\n\nViết chương trình sử dụng con trỏ cấu trúc để hiển thị giờ, phút, giây ra màn hình, và tính khoảng cách giữa 2 mốc thời gian.\nViết chương trình sử dụng con trỏ cấu trúc thể hiện ngày, tháng, năm ra màn hình, và tính khoảng cách giữa 2 ngày.\nViết chương trình khai báo kiểu dữ liệu thể hiện một số phức. Sử dụng kiểu này để viết hàm tính tổ ng, hiệu, tích của hai số phức.\nViết chương trình khai báo kiểu dữ liệu để biểu diễn một phân số. Hãy viết hàm thực hiện những công việc sau:\n\nTính tổng, hiệu, tích, thương hai phân số.\nRút gọn phân số.\nQui đồng hai phân số.\nSo sánh hai phân số.\n\nViết chương trình khai báo kiểu dữ liệu để biểu diễn một hỗn số. Hãy viết hàm thực hiện những công việc sau:\n\nĐổi hỗn số sang phân số\nTính tổng, tích hai hỗn số\n\nViết chương trình khai báo kiểu dữ liệu để biểu diễn một điểm trong hệ tọa độ 0xy. Hãy viết hàm thực hiện các công việc sau:\n\nTìm những điểm đối xứng của nó qua tung độ, hoành độ, toạ độ tâm.\nHãy tính tổng, hiệu, tích của hai điểm trong mặt phẳng toạ độ 0xy.\nTính khoảng cách giữa hai điểm.\n\nCho một hình trụ có các thông tin sau: BanKinh (bán kính hình trụ kiểu số thực), ChieuCao (chiều cao hình trụ kiểu số thực). Hãy thực hiện các công việc sau.\n\nNhập dữ liệu cho hình trụ trên.\nTính diện tích xung quanh, diện tích toàn phần, thể tích hình trụ.\n\n\n\n\nBài tập luyện tập và nâng cao\n\nViết chương trình tạo một mảng các số phức. Hãy viết hàm tính tổng, tích các số phức có trong mảng.\nViết chương trình tạo một mảng các phân số. Hãy viết hàm thực hiện các công việc sau:\n\nTính tổng tất cả các phân số (kết quả dưới dạng phân số tối giản)\nTìm phân số lớn nhất, phân số nhỏ nhất.\nSắp xếp mảng tăng dần.\n\nViết chương trình khai báo kiểu dữ liệu STACK (cơ chế LIFO). Viết hàm làm những công việc sau:\n\nKiểm tra STACK rỗng\nKiểm tra STACK đầy\nThêm phần tử vào STACK\nLấy phần tử ra khỏi STACK\n\nTổ chức dữ liệu để quản lí sinh viên bằng cấu trúc mẫu tin trong một mảng N phần tử, mỗi phần tử có cấu trúc như sau:\n\nMã sinh viên.\nTên.\nNăm sinh.\nĐiểm toán, lý, hoá, điểm trung bình.\n\nViết chương trình thực hiện những công việc sau:\n\nNhập danh sách các sinh viên cho một lớp học.\nXuất danh sách sinh viên ra màn hình.\nTìm sinh viên có điểm trung bình cao nhất.\nSắp xếp danh sách lớp theo thứ tự tăng dần của điểm trung bình.\nSắp xếp danh sách lớp theo thứ tự giảm dần của điểm toán.\nTìm kiếm và in ra các sinh viên có điểm trung bình lớn hơn 5 và không có môn nào dưới 3.\nTìm sinh viên có tuổi lớn nhất.\nNhập vào tên của một sinh viên. Tìm và in ra các thông tin liên quan đến sinh viên đó (nếu có).\n\nTổ chức dữ liệu quản lí danh mục các bộ phim VIDEO, các thông tin liên quan đến bộ phim này như sau:\n\nTên phim (tựa phim).\nThể loại (3 loại: hình sự, tình cảm, hài).\nTên đạo diễn.\nTên điễn viên nam chính.\nTên diễn viên nữ chính.\nNăm sản xuất.\nHãng sản xuất\n\nViết chương trình thực hiện những công việc sau:\n\nNhập vào bộ phim mới cùng với các thông tin liên quan đến bộ phim này.\nNhập một thể loại: In ra danh sách các bộ phim thuộc thể loại này.\nNhập một tên nam diễn viên. In ra các bộ phim có diễn viên này đóng.\nNhập tên đạo diễn. In ra danh sách các bộ phim do đạo diễn này dàn dựng.\n\nMột thư viện cần quản lý thông tin về các đầu sách. Mỗi đầu sách bao gồm các thông tin sau: MaSSach (mã số sách), TenSach (tên sách), TacGia (tác giả), SL (số lượng các cuốn sách của đầu sách). Viết chương trình thực hiện các chức năng sau:\n\nNhập vào một danh sách các đầu sách (tối đa là 100 đầu sách)\nNhập vào tên của quyển sách. In ra thông tin đầy đủ về các sách có tên đó, nếu không có thì tên của quyển sách đó thì báo là: Không Tìm Thấy.\nTính tổng số sách có trong thư viện.\n\nViết chương trình tạo một mảng danh sách các máy tính của một cửa hàng, thông tin của một máy tính bao gồm:\n\nLoại máy\nNơi sản xuất\nThời gian bảo hành\n\n\nViết hàm nhập một dãy các loại máy tính có thông tin như trên.\nHãy viết hàm thống kê xem có bao nhiêu máy có thời gian bảo hành là 1 năm.\nIn ra danh sách các máy tính có xuất xứ từ Mỹ.\n\nĐể lắp ráp một máy vi tính hoàn chỉnh cần phải có tối thiểu 10 linh kiện loại A và có thể lắp bổ sung thêm vào khoảng tối đa 8 linh kiện loại B. Tại một cửa hàng vi tính cần quản lý bán hàng các loại linh kiện t ại cửa hàng. Thông tin về một loại linh kiện gồm có: Tên linh kiện, quy cách, loại, đơn giá loại 1 (chất lượng tốt - số nguyên), đơn giá loại 2 (chất lượng thường - số nguyên). Viết chương trình thực hiện những công việc sau:\n\nNhập vào thông tin về các linh kiện có ở cửa hàng.\nXuất danh sách các linh kiện đã nhập theo thứ tự tăng dần của loại linh kiện và tên linh kiện.\nCho biết đã có đủ 10 linh kiện loại A cần thiết lắp ráp máy hay chưa?\n\nMột cửa hàng cần quản lý các mặt hàng, thông tin một mặt hàng bao gồm:\n\nMã hàng.\nTên mặt hàng.\nSố lượng.\nĐơn giá.\nSố lượng tồn.\nThời gian bảo hành (tính theo đơn vị tháng).\n\n\nHãy nhập vào một danh sách các mặt hàng.\nTìm mặt hàng có số lượng tồn nhiều nhất.\nTìm mặt hàng có số lượng tồn ít nhất.\nTìm mặt hàng có giá tiền cao nhất.\nIn ra những mặt hàng có thời gian bảo hành lớn hơn 12 tháng.\nSắp xếp các mặt hàng theo thứ tự tăng dần của số lượng tồn.\n\nViết chương trình quản lý hồ sơ nhân viên trong một công ty, chương trình thực hiện những công việc sau:\n\nHọ và tên.\nPhái.\nNgày sinh.\nĐịa chỉ.\nLương cơ bản.\nBảo hiểm xã hội.\nThưởng.\nPhạt.\nLương thực lĩnh = Lương cơ bản + Thưởng - Bảo hiểm xã hội - Phạt.\n\n\nNhập vào hồ sơ của các nhân viên trong công ty.\nXuất danh sách các nhân viên theo lương thực lĩnh giảm dần bằng 2 cách sau:\n\nCấp phát vùng nhớ tĩnh.\nCấp phát vùng nhớ động.\n\n\n(*) Viết chương trình quản lý lớp học của một trường. Các thông tin của một lớp học như sau:\n\nTên lớp.\nSĩ số.\nDanh sách các sinh viên trong lớp.\n\n\nNhập vào danh sach các lớp với thông tin yêu cầu như trên.\nIn danh sách các lớp có trên 5 sinh viên có điểm trung bình loại giỏi.\nTìm lớp có nhiều sinh viên nhất.\nTìm lớp có ít sinh viên nhất.\nTìm sinh viên có điểm trung bình cao nhất.\nTìm lớp có số lượng sinh viên đạt điểm trung bình loại giỏi nhiều nhất.\n\nViết chương trình quản lý vé tàu, thông tin một vé tàu như sau:\n\nNgày giờ khởi hành, ngày giờ đến.\nGa đi, ga đến.\nLoại tàu, loại chỗ ngồi (ngồi, nằm, cứng, mềm).\nSố toa, số ghế.\n\n\nViết hàm nhập vào danh sách các vé tàu.\nIn danh sách các vé tàu có ga đến là Huế.\nIn danh sách các vé tàu có ga đến là Hà Nội và đi ngày 8/6/2005.\nĐếm xem có bao nhiêu khách đi tàu loại chỗ ngồi là nằm cứng.\n\nViết chương trình tính tiền điện hàng tháng của các hộ gia đình, thông tin các khách hàng như sau:\n\nKỳ thu, từ ngày… đến ngày…\nTên khách hàng, mã khách hàng.\nĐịa chỉ.\nĐiện năng tiêu thụ (Kwh).\n\n\nNhập vào danh sách các khách hàng.\nXuất danh sách hoá đơn theo thứ tự tăng dần của điện năng tiêu thụ.\nTính tiền điện của các khách hàng theo quy định sau.\n\n100 kw đầu tiên là 550 đ / kw - 50 kw tiếp theo là 900 đ / kw\n50 kw tiếp theo là 1210 đ / kw\nThuế 10% trên tổng số tiền phải trả\n\nTính tổng số tiền thu được của các khách hàng.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CẤU TRÚC</span>"
    ]
  },
  {
    "objectID": "chapter-8.html#tóm-tắt",
    "href": "chapter-8.html#tóm-tắt",
    "title": "8  KIỂU DỮ LIỆU CẤU TRÚC",
    "section": "8.3 TÓM TẮT",
    "text": "8.3 TÓM TẮT\nKiểu dữ liệu có cấu trúc cho phép ta định nghĩa những kiểu dữ liệu bất kỳ trên cơ sở là những kiểu dữ liệu cơ bản có sẵn trong ngôn ngữ lập trình. Khi xây dựng xong kiểu dữ liệu mới ta phải định nghĩa những thao tác cho kiểu dữ liệu đó. Những kiểu dữ liệu tự định nghĩa này thông thường có rấ t nhiều thành phần, mỗi thành phần cũng có thể là một kiểu dữ liệu tự định nghĩa, vấn đề là ta chọn kiểu dữ liệu cơ bản nào để xây dựng nên chúng sao cho phù hợp về mặt kiểu dữ liệu và phù hợp về kích thước lưu trữ (vừa đủ). Cách sử dụng những kiểu dữ liệu tự định nghĩa cũng giống như các kiểu dữ liệu cơ bản. Muốn sử dụng phải khai báo biến, khi truy cập các thành phần phải truy cập theo quy ước. Nếu thành phần cấu trúc có kiểu dữ liệu là số thực thì khi sử dụng hàm scanf() phải thông qua biến trung gian rồi gán lại cho thành phần cấu trúc đó. Đối với mảng các kiểu dữ liệu có cấu trúc ta nên xử lý cho từng thành phần cấu trúc rồi mới xử lý cho mảng cấu trúc bằng cách dùng vòng lặp.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>KIỂU DỮ LIỆU CẤU TRÚC</span>"
    ]
  },
  {
    "objectID": "chapter-9.html",
    "href": "chapter-9.html",
    "title": "9  KIỂU DỮ LIỆU TẬP TIN",
    "section": "",
    "text": "9.1 LÝ THUYẾT\nChương này sẽ trình bày cấu trúc tập tin, cài đặt các thao tác, một số hàm thư viện và ứng dụng trong việc tổ chức dữ liệu trên tập tin.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>KIỂU DỮ LIỆU TẬP TIN</span>"
    ]
  },
  {
    "objectID": "chapter-9.html#lý-thuyết",
    "href": "chapter-9.html#lý-thuyết",
    "title": "9  KIỂU DỮ LIỆU TẬP TIN",
    "section": "",
    "text": "Khái niệm\nTrong các chương trình trước thì các dữ liệu đưa vào chương trình chỉ được tồn tại trong RAM, khi thoát chương trình thì tất cả dữ liệu đều bị mất. Để khắc phục tình trạng này C/C++ cung cấp cho ta các hàm thư viện để lưu trữ và truy xuất tập tin, đó là kiểu FILE. Và ở đây ta chỉ đề cập đến 2 loại tập tin:\n\nTập tin văn bản: là tập tin lưu trữ dưới dạng ký tự.\nTập tin nhị phân: là tập tin dùng lưu trữ dưới dạng nhị phân.\n\n\n\nThao tác với tập tin\nQuá trình thao tác trên tập tin thông qua 4 bước:\n\nKhai báo con trỏ cho tập tin.\nMở tập tin.\nXử lý tập tin.\nĐóng tập tin.\n\n\nKhai báo\n\nFILE *⟨tên biến⟩;\n\n\nKhai báo biến con trỏ file f\nFILE *f;\n\n\n\nMở tập tin\n\nfopen(⟨đường dẫn tên tập tin⟩, ⟨kiểu truy nhập⟩);\nCác kiểu truy nhập tập tin thông dụng:\n\nt là kiểu truy nhập tập tin đối với dạng tập tin văn bản.\nb là kiểu truy nhập tập tin đối với dạng tập tin nhị phân.\nr mở ra để đọc (ready only).\nw mở ra để ghi (create / write).\na mở ra để thêm vào (append).\nr+ mở ra để đọc và ghi (modify).\n\n\n\nMở tập tin văn bản tên DATA.TXT để đọc\n// Khai báo biến con trỏ f \nFILE *f; \n// Mở tập tin văn bản và f quản lý tập tin này\nf = fopen(\"C:\\\\DATA.TXT\", \"rt\");\n\n\n\nĐọc tập tin nhị phân\nfread(&ptr, size, len, FILE *);\n\n\nGhi tập tin nhị phân\nfwrite(&prt, size, len, FILE *);\n\n\nĐóng tập tin\nSau khi không còn làm việc với tập tin, để đảm bảo an toàn cho dữ liệu thì nhất thiết ta phải đóng tập tin lại.\n\nĐóng một tập tin\nfclose(⟨biến con trỏ tập tin⟩);\nĐóng tất cả tập tin\nfcloseall();\n\n\nĐóng tập tin f và tập tin g\nfclose(f);\nfclose(g);\n\n\n\nXoá tập tin\nremove(⟨đường dẫn + tên tập tin⟩); \n\n\nĐổi tên tập tin\nrename(⟨tên tập tin cũ⟩, ⟨tên tập tin mới⟩);\n\n\nDi chuyển con trỏ tập tin:\nfseek(FILE *, ⟨độ dời⟩, ⟨mốc⟩); \nmốc:\n\nSEEK_SET dời dến đầu tập tin (giá trị 0).\nSEEK_CUR dời vị trí hiện hành (giá trị 1).\nSEEK_END dời đến cuối tập tin (giá trị 2).\n\n\nDi chuyển vị trí con trỏ về sau 5 bytes, sau đó di chuyển về trước 4 bytes\nfseek(f, +5, SEEK_CUR);\nfseek(f, -4, SEEK_CUR);\n\n\n\nCho biết vị trí con trỏ file\nftell(FILE *);\n\n\n\nCác ví dụ minh hoạ\n\nKiểm tra tập tin một tập tin có thể mở được không?\nvoid KiemTra(char *tenfile)\n{ \n    FILE *f = fopen(tenfile, \"rt\");\n    if(f == NULL)\n    {\n        printf(\"Khong mo duoc tap tin %s\", tenfile);\n        return;\n    }\n    printf(\"Tap tin %s da duoc mo\", tenfile);\n    fclose(f);\n}\n\n\nTập tin văn bản\n\nViết chương trình phát sinh ngẫu nhiên ma trận a kích thước 5\\times6, lưu ma trận này vào file data.txt. Đọc lại file data.txt đưa dữ liệu vào ma trận b và xuất ra màn hình xem kết quả lưu đúng không? Cấu trúc của file data.txt như sau:\n\nDòng đầu lưu 2 số nguyên: m,n thể hiện số dòng và số cột của ma trận.\nm dòng tiếp theo, mỗi dòng gồm n phần tử là giá trị các phần tử trên một dòng của ma trận.\n\n#include&lt;stdio.h&gt; \n#include&lt;conio.h&gt; \n#include&lt;stdlib.h&gt;\n#define MAX 100 \nvoid LuuFile(char *tenfile, int a[MAX][MAX], int m, int n) \n{ \n    FILE *f; \n    f=fopen(tenfile, \"wt\"); \n    if(f==NULL) \n    { \n        printf(\"\\nKhong tao duoc file.\"); \n        getch(); \n        exit(0); \n    } \n    fprintf(f, \"%d %d\\n\", m, n); \n    for(int i=0; i&lt;m; i++) \n    { \n        for(int j=0; j&lt;n; j++) \n            fprintf(f, \"%d\\t\", a[i][j]); \n        fprintf(f, \"\\n\"); } \n    fclose(f); \n}\nvoid DocFile(char *tenfile, int a[MAX][MAX], int &m, int &n) \n{ \n    FILE *f; \n    f=fopen(tenfile, \"rt\"); \n    if(f==NULL) \n    { \n        printf(\"\\nKhong doc duoc file.\"); \n        getch(); \n        exit(0); \n    } \n    fscanf(f, \"%d%d\", &m, &n); \n    for(int i=0; i&lt;m; i++) \n    { \n        for(int j=0; j&lt;n; j++) \n            fscanf(f, \"%d\", &a[i][j]); \n    } \n    fclose(f); \n}\nvoid main() \n{ \n    int i, j;\n    int a[MAX][MAX], m=5, n=6;\n    int b[MAX][MAX], x, y;\n    randomize(); \n    for(i=0; i&lt;m; i++) \n        for(j=0; j&lt;n; j++) \n            a[i][j]=random(1000); \n    LuuFile(\"data.txt\", a, m, n); \n    DocFile(\"data.txt\", b, x, y); \n    for(i=0; i&lt;x; i++) \n    { \n        for(j=0; j&lt;y; j++) \n            printf(\"%d\\t\", b[i][j]); \n        printf(\"\\n\"); \n    } \n} \n\n\nViết chương trình tạo tập tin văn bản OUT.TXT gồm n số nguyên, các số của dãy được tạo ngẫu nhiên có giá trị tuyệt đối không vượt quá M (n,M đọc từ tập tin IN.TXT). Kết quả chương trình là 1 tập tin văn bản có dòng thứ nhất ghi số n; n dòng tiếp theo ghi các số tạo được, mỗi số trên một dòng.\nvoid NhapFile(char *tenfile, int &n, int &M) \n{ \n    FILE *fi; \n    fi = fopen(tenfile, \"rt\"); \n    fscanf(fi, \"%d%d\", &n, &M); \n    fclose(fi); \n}\nvoid XuatFile(char *tenfile, int n, int M) \n{ \n    FILE *fo; \n    fo = fopen(tenfile, \"wt\"); \n    fprintf(fo, \" %d\\n\", n); \n    randomize(); \n    for(; n &gt; 0; n --) \n        fprintf(fo, \"%d\\n\", random((2 * M + 1) - M)); \n    fclose(fo); \n} \nvoid main() \n{ \n    int n, M;\n    Nhap(\"IN.TXT\", n, M); \n    Xuat(\"OUT.TXT\", n, M); \n} \n\n\n\nTập tin nhị phân\n\nViết hàm đọc/ghi một danh sách sinh viên của một lớp vào tập tin\nvoid Doc(char *tenfile, SINHVIEN ds[], int &siso) \n{ \n    FILE *fi; \n    fi = fopen(\"SV.DAT\", \" rb\"); \n    fseek(fi, 0, SEEK_END); \n    siso = (ftell(fi) + 1) / sizeof(SINHVIEN);\n    fseek(fi, 0, SEEK_SET); \n    fread(ds, sizeof(SINHVIEN), siso, fi); \n    fclose(fi); \n}\nvoid Ghi(char *tenfile, SINHVIEN ds[], int siso) \n{ \n    FILE *fo; \n    fo = fopen(tenfile, \" wb\"); \n    fwrite(ds, sizeof(SINHVIEN), siso, fo);\n    fclose(fo); \n}",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>KIỂU DỮ LIỆU TẬP TIN</span>"
    ]
  },
  {
    "objectID": "chapter-9.html#bài-tập",
    "href": "chapter-9.html#bài-tập",
    "title": "9  KIỂU DỮ LIỆU TẬP TIN",
    "section": "9.2 BÀI TẬP",
    "text": "9.2 BÀI TẬP\n\nBài tập cơ bản\n\nViết chương trình tạo tập tin văn bản chứa 1 dãy số nguyên bất kỳ.\nViết chương trình tạo tập tin nhị phân chứa 10000 số nguyên bất kỳ ghi vào file SONGUYEN.INP. Mỗi dòng 10 số, sau đó viết chương trình đọc file SONGUYEN.INP, sắp xếp theo thứ tự tăng dần và lưu kết quả vào file SONGUYEN.OUT.\nViết chương trình tạo một file chứa 10000 số nguyên ngẫu nhiên đôi một khác nhau trong phạm vi từ 1 đến 32767 và đặt tên là SONGUYEN.INP.\nViết chương trình tạo một file chứa các số nguyên có tên SONGUYEN.INP. Sau đó đọc file SONGUYEN.INP và ghi các số chẵn vào file SOCHAN.OUT và những số lẻ vào file SOLE.OUT.\nViết chương trình ghi vào tập tin SOCHAN.DAT các số nguyên chẵn từ 0 đến 100.\nViết chương trình đọc tập tin SOCHAN.DAT và xuất ra màn hình, mỗi dòng 30 số.\nViết chương trình giả lập lệnh COPY CON để tạo tập tin v ăn bản. Khi kết thúc tập tin nhấn phím F6 để lưu\nViết chương trình giả lập lệnh TYPE để in nội dung của tập tin văn bản ra màn hình.\nViết chương trình kiểm tra một tập tin nào đó có trong một thư mục được chỉ định hay không?\nViết chương trình giả lập lệnh DEL để xoá tập tin. Yêu cầu nhập đường dẫn và tên tập tin, kiểm tra sự tồn tại của tập tin, nếu có thì xoá tập tin được chỉ định.\nViết chương trình giả lập lệnh RENAME để đổi tên một tập tin.\nViết chương trình tạo file văn bản có tên là MATRIX.INP có cấu trúc như sau:\n\nDòng đầu ghi hai số m,n.\nTrong m dòng tiếp theo mỗi dòng ghi n số và các số các nhau một khoảng cách.\n\nHãy kiểm tra xem trong file đó có bao nhiêu số nguyên tố. Kết quả cần ghi vào file MATRIX.OUT có nội dung là một số nguyên đó là số lượng các số nguyên tố trong file MATRIX.INP.\nCho số nguyên n, hãy in tam giác PASCAL gồm n dòng\n\nDữ liệu vào: tập tin văn bản PAS.INP gồm 1 dòng chứa giá trị n.\nKết quả: đưa ra tập tin văn bản PAS.OUT thể hiện một tam giác PASCAL n dòng.\n\nCho mảng các số nguyên, hãy sắp xếp mảng theo thứ tự tăng dần.\nDữ liệu vào: tập tin văn bản ARRAY.INP gồm 2 dòng\n\nDòng 1 chứa số nguyên n (n\\leq100).\nDòng 2 chứa n số nguyên.\n\nKết quả: Đưa ra tập tin văn bản ARRAY.OUT gồm hai dòng\n\nDòng 1 chứa n phần tử của mảng các số nguyên.\nDòng 2 chứa n số nguyên được xếp tăng dần.\n\nCho mảng các số nguyên, tìm phần tử lớn nhất của mảng.\nDữ liệu vào: tập tin văn bản ARRAY.INP gồm hai dòng:\n\nDòng 1 chứa số nguyên n (n\\leq100).\nDòng 2 chứa n số nguyên.\n\nKết quả: Đưa ra tập tin văn bản ARRAY.OUT gồm 1 dòng ghi 2 giá trị x,y trong đó x là giá trị lớn nhất, y là vị trí của x trong mảng.\n\n\n\nBài tập luyện tập và nâng cao\n\nCho mảng các số nguyên, tính tổng các phần tử của mảng.\nDữ liệu vào: tập tin văn bản ARRAY.INP gồm hai dòng\n\nDòng 1 chứa số nguyên n (n\\leq10)\nDòng 2 chứa n số nguyên\n\nKết quả: Đưa ra tập tin văn bản ARRAY.OUT gồm một dòng ghi tổng các phần tử trong mảng.\nCho mảng các số nguyên, hãy liệt kê các phần tử là số nguyên tố\nDữ liệu vào: tập tin văn bản NT.INP gồm hai dòng\n\nDòng 1 chứa số nguyên n (n\\leq100)\nDòng 2 chứa n số nguyên\n\nKết quả: đưa ra tập tin văn bản NT.OUT gồm hai dòng:\n\nDòng 1 chứa số lượng các phần tử nguyên tố trong mảng.\nDòng 2 liệt kê các số nguyên tố đó.\n\n(*) Tạo file văn bản có tên là INPUT.TXT có cấu trúc như sau:\n\nDòng đầu tiên ghi N (N là số nguyên dương nhập từ bàn phím).\nTrong các dòng tiếp theo ghi N số nguyên ngẫu nhiên trong phạm vi từ 0 đến 100, mỗi dòng 10 số (các số cách nhau ít nhất một khoảng trắng).\n\nHãy đọc dữ liệu của file INPUT.TXT và lưu vào mảng một chiều A. Thực hiện các công việc sau:\n\nTìm giá trị lớn nhất của mảng A.\nĐếm số lượng số chẵn, số lượng số lẻ của mảng A.\nHãy sắp xếp các phần tử theo thứ tự tăng dầ n.\n\nHãy ghi các kết quả vào file văn bản có tên OUTPUT.TXT\n(*) Viết chương trình nhập và lưu hồ sơ của sinh viên vào một file có tên là DSSV.TXT. Sau đó đọc file DSSV.TXT và cất vào mảng, hãy sắp xếp các hồ sơ sinh viên theo thứ tự giảm dần theo điểm trung bình môn học rồi in ra màn hình hồ sơ các sinh viên theo thứ tự đó ra màn hình có thông tin như sau:\n\nMã số sinh viên.\nHọ và tên sinh viên.\nĐiểm trung bình kiểm tra.\nĐiểm thi hết môn.\nĐiểm trung bình môn học tính bằng (Điểm trung bình kiểm tra + điểm thi hết môn)/2.\n\n(*) Tạo một file text có tên là INPUT.TXT có cấu trúc như sau:\n\nDòng đầu tiên ghi hai số M và N (M,N là hai số nguyên dương nhập từ bàn phím).\nTrong M dòng tiếp theo mỗi dòng ghi N số nguyên ngẫu nhiên trong phạm vi từ 0 đến 100 (các số này cách nhau ít nhất một khoảng trắng).\n\nHãy đọc dữ liệu từ file trên và lưu vào mảng hai chiều. Rồi thực hiện các công việc sau:\n\nTìm giá trị lớn nhất của ma trận.\nĐếm số lượng số chẵn, lẽ, nguyên tố có trong ma trận.\nHãy tính tổng các phần tử trên mỗi dòng của ma trận.\n\nHãy ghi kết quả này vào file văn bản có tên là OUTPUT.TXT\n(**) Xét dãy số \\left\\{  a_{1},a_{2},...,a_{N}\\right\\}. Một đoạn con của dãy là dãy các phần tử liên tiếp nhau được xác định bởi chỉ số của số bắt đầu (L) và chỉ số của số cuối cùng (R). Tổng các số trên đoạn được gọi là tổng đoạn. Yêu cầu: Cho dãy \\left\\{  a_{1},a_{2},...,a_{N}\\right\\}, hãy tìm đoạn con có tổng đoạn lớn nhất (T).\nDữ liêu được cho trong tập tin văn bản SUMMAX.INP\n\nDòng thứ nhất chứ số nguyên N (0&lt;N\\leq30000)\nN dòng tiếp theo, mỗi dòng chứa một số là các số của dãy đã cho theo đúng thứ tự. Giá trị tuyệt đối của mội số không vượt quá 30000 Kết quả tìm được ghi vào tập tin văn bản SUMMAX.OUT\n\n(*) Cho dãy \\left\\{  a_{1},a_{2},...,a_{N}\\right\\}, hãy tìm đoạn con tăng dần có tổng lớn nhất.\nDữ liệu: được cho trong tập tin AMAX.INP\n\nDòng 1 chứa số nguyên N (0&lt;N\\leq30000).\nN dòng tiếp theo, mỗi dòng chứa một số là các số của dãy đãy cho theo đúng thứ tự. Giá trị tuyệt đối của mỗi số không vược quá 30000.\n\nKết quả tìm được ghi vàp tin văn bản AMAX.OUT gồm hai dòng:\n\nDòng 1 ghi tổng của dãy con.\nDòng 2 ghi mảng con tăng dần có tổng lớn nhất.\n\nViết chương trình nhập lý lịch một nhân viên vào danh sách các nhân viên. Khi không nhập nữa bấm phím ESC và ghi vào tập tin NHANVIEN.DAT sau đó:\n\nĐọc từ tập tin NHANVIEN.DAT vừa tạo và in danh sách các nhân viên lên màn hình.\nTìm và in lý lịch một nhân viên bằng các nhập và họ tên hoặc mã số nhân viên.\n\n(**) Để lắp ráp một máy vi tính hoàn chỉnh cần phải có tối thiểu 10 linh kiện loại A và có thể lắp bổ sung thêm vào khoả ng tối đa 8 linh kiện loại B. Tại một cửa hàng vi tính cần quản lý bán hàng các loại linh kiện tại cửa hàng. Thông tin về một loại linh kiện gồm có: Tên linh kiện, quy cách, loại, đơn giá loại 1 (chất lượng tốt - số nguyên), đơn giá loại 2 (chất lượng thường - số nguyên). Viết chương trình thực hiện những công việc sau:\n\nNhập vào thông tin của các loại linh kiện có ở cửa hàng. Xuất danh sách các linh kiện đã nhập theo thứ tự tăng dần của loại linh kiện và tên linh kiện. Cho biết đã có đủ 10 linh kiện loại A cần thiết để lắp ráp máy tính hay chưa?\nVới giả định là cửa hàng đã có đủ 10 linh kiện loại A để lắp ráp máy. Nhập vào một số tiền để lắp ráp một máy tính. Có thể lắp được một máy tính hoàn chỉnh với các linh kiện toàn bộ theo đơn giá loại 1 hay đơn giá loại 2 hay không? Nếu số tiền trong khoảng giữa thì hãy tìm một phương án gồm những linh kiện theo đơn giá 1 và linh kiện theo đơn giá 2 để lắp?\nTất cả dữ liệu phải lưu ở tập tin.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>KIỂU DỮ LIỆU TẬP TIN</span>"
    ]
  },
  {
    "objectID": "chapter-9.html#tóm-tắt",
    "href": "chapter-9.html#tóm-tắt",
    "title": "9  KIỂU DỮ LIỆU TẬP TIN",
    "section": "9.3 TÓM TẮT",
    "text": "9.3 TÓM TẮT\nMục đích của kiểu dữ liệu tập tin cho phép chúng ta lưu lại những thông tin cần thiết tương đối lớn: những dữ liệu đầu vào, những kết quả của chương trình hoặc những dữ liệu dùng để kiểm tra chương trình. Khi thao tác trên tập tin phải thông qua 4 bước: Khai báo con trỏ trỏ đến tập tin, Mở tập tin, Xử lý trên tập tin và cuối cùng là Đóng tập tin. Lưu ý khi mở tập tin để ghi thì phải cẩn thận với thao tác tạo mới hay chỉnh sửa nội dung tập tin, di chuyển con trỏ hợp lý để tránh mất thông tin. Sử dụng hàm thao tác trên tập tin phải dùng đúng loại hàm cho tập tin kiểu nhị phân hay kiểu văn bản.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>KIỂU DỮ LIỆU TẬP TIN</span>"
    ]
  }
]